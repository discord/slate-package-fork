{"version":3,"file":"slate.js","sources":["../src/utils/key-utils.js","../src/utils/path-utils.js","../src/models/point.js","../src/models/data.js","../src/models/mark.js","../src/models/decoration.js","../src/models/selection.js","../src/utils/is-object.js","../src/models/range.js","../src/models/annotation.js","../src/models/document.js","../src/models/inline.js","../src/models/text.js","../src/models/node.js","../src/models/block.js","../src/models/value.js","../src/operations/apply.js","../src/operations/invert.js","../src/models/operation.js","../src/models/change.js","../src/plugins/commands.js","../src/utils/text-utils.js","../src/commands/at-range.js","../src/commands/by-path.js","../src/commands/on-history.js","../src/commands/on-selection.js","../src/commands/on-value.js","../src/plugins/queries.js","../src/utils/slate-error.js","../src/plugins/schema.js","../src/commands/with-intent.js","../src/plugins/core.js","../src/controllers/editor.js","../src/models/leaf.js","../src/utils/mixin.js","../src/interfaces/object.js","../src/interfaces/model.js","../src/utils/memoize.js","../src/interfaces/node.js","../../../node_modules/rollup-plugin-node-globals/src/global.js","../src/utils/identity.js","../src/interfaces/element.js","../src/interfaces/range.js","../src/index.js"],"sourcesContent":["/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","import { List } from 'immutable'\n\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  const m = min(path, target)\n\n  for (let i = 0; i < m; i++) {\n    const pv = path.get(i)\n    const tv = target.get(i)\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1\n  }\n\n  // Paths should now be equal, otherwise something is wrong\n  return path.size === target.size ? 0 : null\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\nfunction getAncestors(path) {\n  const ancestors = List().withMutations(list => {\n    for (let i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i))\n    }\n  })\n\n  return ancestors\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isEqual(path, target) {\n  return path.equals(target)\n}\n\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isOlder(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl > tl\n}\n\n/**\n * Is an `any` object a path?\n *\n * @param {Mixed} any\n * @return {Boolean}\n */\n\nfunction isPath(any) {\n  return (\n    (List.isList(any) || Array.isArray(any)) &&\n    any.every(n => typeof n === 'number')\n  )\n}\n\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false\n  const p = path.butLast()\n  const t = target.butLast()\n  return p.equals(t)\n}\n\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isYounger(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl < tl\n}\n\n/**\n * Lift a `path` to refer to its `n`th ancestor.\n *\n * @param {List} path\n * @return {List}\n */\n\nfunction lift(path, n = 1) {\n  const ancestor = path.slice(0, -1 * n)\n  return ancestor\n}\n\n/**\n * Drop a `path`, returning a relative path from a depth of `n`.\n *\n * @param {List} path\n * @param {Number} n\n * @return {List}\n */\n\nfunction drop(path, n = 1) {\n  const relative = path.slice(n)\n  return relative\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\nfunction transform(path, operation) {\n  const { type, position, path: p } = operation\n\n  if (\n    type === 'add_mark' ||\n    type === 'insert_text' ||\n    type === 'remove_mark' ||\n    type === 'remove_text' ||\n    type === 'set_mark' ||\n    type === 'set_node' ||\n    type === 'set_selection' ||\n    type === 'set_value' ||\n    type === 'add_annotation' ||\n    type === 'remove_annotation' ||\n    type === 'set_annotation' ||\n    path.size === 0\n  ) {\n    return List([path])\n  }\n\n  const pIndex = p.size - 1\n  const pEqual = isEqual(p, path)\n  const pYounger = isYounger(p, path)\n  const pAbove = isAbove(p, path)\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex)\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pEqual || pAbove) {\n      path = []\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex)\n      path = increment(path, position, pIndex + 1)\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)]\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex)\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex)\n        path = decrement(path, position, pIndex + 1)\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    const { newPath: np } = operation\n\n    if (isEqual(p, np)) {\n      return List([path])\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size))\n      } else {\n        path = np.concat(path.slice(p.size))\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex)\n      }\n\n      // This is the equivalent logic to insert_node for newPath\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1)\n      }\n    }\n  }\n\n  const paths = Array.isArray(path) ? path : [path]\n  return List(paths)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  getAncestors,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  isEqual,\n  isOlder,\n  isPath,\n  isSibling,\n  isYounger,\n  lift,\n  drop,\n  max,\n  min,\n  relate,\n  transform,\n}\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined,\n}\n\n/**\n * Point.\n *\n * @type {Point}\n */\n\nclass Point extends Record(DEFAULTS) {\n  /**\n   * Create a new `Point` with `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Point}\n   */\n\n  static create(attrs = {}) {\n    if (Point.isPoint(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Point.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Point.create\\` only accepts objects or points, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable point properties from `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Point.isPoint(a)) {\n      return {\n        key: a.key,\n        offset: a.offset,\n        path: a.path,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('offset' in a) p.offset = a.offset\n      if ('path' in a) p.path = PathUtils.create(a.path)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('path' in a && !('key' in a)) p.key = null\n      if ('key' in a && !('path' in a)) p.path = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Point.createProperties\\` only accepts objects or points, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Point` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Point}\n   */\n\n  static fromJSON(object) {\n    const { key = null, offset = null, path = null } = object\n\n    const point = new Point({\n      key,\n      offset,\n      path: PathUtils.create(path),\n    })\n\n    return point\n  }\n\n  /**\n   * Check whether all properties of the point are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.key != null && this.offset != null && this.path != null\n  }\n\n  /**\n   * Check whether any property of the point is not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Check whether the point is after another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterPoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset > point.offset) ||\n      PathUtils.compare(this.path, point.path) === 1\n    return is\n  }\n\n  /**\n   * Check whether the point is after a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterRange(range) {\n    if (this.isUnset) return false\n    const is = this.isAfterPoint(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtEndOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtStartOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is before another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforePoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset < point.offset) ||\n      PathUtils.compare(this.path, point.path) === -1\n    return is\n  }\n\n  /**\n   * Check whether the point is before a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforeRange(range) {\n    if (this.isUnset) return false\n    const is = this.isBeforePoint(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is inside a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    if (this.isUnset) return false\n    const is =\n      this.equals(range.start) ||\n      this.equals(range.end) ||\n      (this.isAfterPoint(range.start) && this.isBeforePoint(range.end))\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOfNode(node) {\n    if (this.isUnset) return false\n    const last = node.getLastText()\n    const is = this.key === last.key && this.offset === last.text.length\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOfNode(node) {\n    if (this.isUnset) return false\n\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.offset !== 0) return false\n\n    const first = node.getFirstText()\n    const is = this.key === first.key\n    return is\n  }\n\n  /**\n   * Check whether the point is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isInNode(node) {\n    if (this.isUnset) return false\n    if (node.object === 'text' && node.key === this.key) return true\n    if (node.hasNode(this.key)) return true\n    return false\n  }\n\n  /**\n   * Move the point's offset backward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveBackward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveForward(-n)\n    const point = this.setOffset(this.offset - n)\n    return point\n  }\n\n  /**\n   * Move the point's offset forward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveForward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveBackward(-n)\n    const point = this.setOffset(this.offset + n)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String|Number} path\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  moveTo(path, offset = 0) {\n    let key = this.key\n\n    if (typeof path === 'number') {\n      offset = path\n      path = this.path\n    } else if (typeof path === 'string') {\n      key = path\n      path = key === this.key ? this.path : null\n    } else {\n      key = path.equals(this.path) ? this.key : null\n    }\n\n    const point = this.merge({ key, path, offset })\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToStartOfNode(node) {\n    const first = node.getFirstText()\n    const point = this.moveTo(first.key, 0)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToEndOfNode(node) {\n    const last = node.getLastText()\n    const point = this.moveTo(last.key, last.text.length)\n    return point\n  }\n\n  /**\n   * Normalize the point relative to a `node`, ensuring that its key and path\n   * reference a text node, or that it gets unset.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  normalize(node) {\n    // If both the key and path are null, there's no reference to a node, so\n    // make sure it is entirely unset.\n    if (this.key == null && this.path == null) {\n      return this.setOffset(null)\n    }\n\n    const { key, offset, path } = this\n\n    // PERF: this function gets called a lot.\n    // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n    let target = path && node.getNode(path)\n\n    if (!target) {\n      target = node.getNode(key)\n\n      if (target) {\n        // There is a misalignment of path and key\n        const point = this.merge({\n          path: node.getPath(key),\n        })\n\n        return point\n      }\n    }\n\n    if (!target) {\n      warning(false, \"A point's `path` or `key` invalid and was reset!\")\n\n      const text = node.getFirstText()\n      if (!text) return Point.create()\n\n      const point = this.merge({\n        key: text.key,\n        offset: 0,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target.object !== 'text') {\n      warning(false, 'A point should not reference a non-text node!')\n\n      const text = target.getTextAtOffset(offset)\n      const before = target.getOffset(text.key)\n      const point = this.merge({\n        offset: offset - before,\n        key: text.key,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target && path && key && key !== target.key) {\n      warning(false, \"A point's `key` did not match its `path`!\")\n\n      // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n    }\n\n    let point = this.merge({\n      key: target.key,\n      path: path == null ? node.getPath(target.key) : path,\n      offset: offset == null ? 0 : Math.min(offset, target.text.length),\n    })\n\n    // COMPAT: There is an ambiguity, since a point can exist at the end of a\n    // text node, or at the start of the following one. To eliminate it we\n    // enforce that if there is a following text node, we always move it there.\n    if (point.offset === target.text.length) {\n      const block = node.getClosestBlock(point.path)\n      // TODO: this next line is broken because `getNextText` takes a path\n      const next = block.getNextText()\n\n      if (next) {\n        point = point.merge({\n          key: next.key,\n          path: node.getPath(next.key),\n          offset: 0,\n        })\n      }\n    }\n\n    return point\n  }\n\n  /**\n   * Set the point's key to a new `key`.\n   *\n   * @param {String} key\n   * @return {Point}\n   */\n\n  setKey(key) {\n    if (key != null) {\n      key = KeyUtils.create(key)\n    }\n\n    const point = this.set('key', key)\n    return point\n  }\n\n  /**\n   * Set the point's offset to a new `offset`.\n   *\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  setOffset(offset) {\n    const point = this.set('offset', offset)\n    return point\n  }\n\n  /**\n   * Set the point's path to a new `path`.\n   *\n   * @param {List|Array} path\n   * @return {Point}\n   */\n\n  setPath(path) {\n    if (path != null) {\n      path = PathUtils.create(path)\n    }\n\n    const point = this.set('path', path)\n    return point\n  }\n\n  /**\n   * Return a JSON representation of the point.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      offset: this.offset,\n      path: this.path && this.path.toArray(),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.key\n    }\n\n    return object\n  }\n\n  /**\n   * Unset the point.\n   *\n   * @return {Point}\n   */\n\n  unset() {\n    return this.merge({\n      key: null,\n      offset: null,\n      path: null,\n    })\n  }\n}\n\n/**\n * Export.\n *\n * @type {Point}\n */\n\nexport default Point\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record, Set } from 'immutable'\n\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Data from './data'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Decoration.\n *\n * @type {Decoration}\n */\n\nclass Decoration extends Record(DEFAULTS) {\n  /**\n   * Create a new `Decoration` with `attrs`.\n   *\n   * @param {Object|Decoration} attrs\n   * @return {Decoration}\n   */\n\n  static create(attrs = {}) {\n    if (Decoration.isDecoration(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Decoration.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Decoration.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Decoration.create\\` only accepts objects or decorations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n   * @return {List<Decoration>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Decoration.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Decoration.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable decoration properties from `attrs`.\n   *\n   * @param {Object|String|Decoration} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Decoration.isDecoration(a)) {\n      return {\n        type: a.type,\n        data: a.data,\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        mark: Mark.create(a.mark),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('type' in a) p.type = a.type\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Decoration.createProperties\\` only accepts objects or decorations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Decoration` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Decoration}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    let { type, data } = object\n\n    if (object.mark && !type) {\n      warning(\n        false,\n        'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.'\n      )\n\n      type = object.mark.type\n      data = object.mark.data\n    }\n\n    if (!type) {\n      throw new Error(\n        `Decorations must be created with a \\`type\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const decoration = new Decoration({\n      type,\n      data: Data.create(data || {}),\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return decoration\n  }\n\n  /**\n   * Set new `properties` on the decoration.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.merge(properties)\n    return decoration\n  }\n\n  /**\n   * Return a JSON representation of the decoration.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Decoration}\n */\n\nexport default Decoration\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined,\n}\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nclass Selection extends Record(DEFAULTS) {\n  /**\n   * Create a new `Selection` with `attrs`.\n   *\n   * @param {Object|Selection} attrs\n   * @return {Selection}\n   */\n\n  static create(attrs = {}) {\n    if (Selection.isSelection(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Selection.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Selection.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Selection.create\\` only accepts objects, ranges or selections, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable selection properties from `attrs`.\n   *\n   * @param {Object|String|Selection} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Selection.isSelection(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n      return p\n    }\n\n    throw new Error(\n      `\\`Selection.createProperties\\` only accepts objects, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Selection` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Selection}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, isFocused = false, marks = null } = object\n    const selection = new Selection({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return selection\n  }\n\n  /**\n   * Check whether the selection is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Set the `isFocused` property to a new `value`.\n   *\n   * @param {Boolean} value\n   * @return {Selection}\n   */\n\n  setIsFocused(value) {\n    const selection = this.set('isFocused', value)\n    return selection\n  }\n\n  /**\n   * Set the `marks` property to a new set of `marks`.\n   *\n   * @param {Set} marks\n   * @return {Selection}\n   */\n\n  setMarks(marks) {\n    const selection = this.set('marks', marks)\n    return selection\n  }\n\n  /**\n   * Set new `properties` on the selection.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Selection.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const selection = this.merge(props)\n    return selection\n  }\n\n  /**\n   * Return a JSON representation of the selection.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexport default Selection\n","/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\nexport const TYPES = {\n  annotation: '@@__SLATE_ANNOTATION__@@',\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Determine whether a `value` is of `type`.\n *\n * @param {string} type\n * @param {any} value\n * @return {boolean}\n */\n\nexport default function isObject(type, value) {\n  return !!(value && value[TYPES[type]])\n}\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Decoration from './decoration'\nimport Point from './point'\nimport Selection from './selection'\nimport isObject from '../utils/is-object'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      if (attrs.object === 'range') {\n        return attrs\n      } else {\n        return Range.fromJSON(Range.createProperties(attrs))\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    const range = new Range({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return range\n  }\n\n  /**\n   * Check if a `value` is a `Range`, or is range-like.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isRange(value) {\n    return (\n      isObject('range', value) ||\n      Decoration.isDecoration(value) ||\n      Selection.isSelection(value)\n    )\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record } from 'immutable'\n\nimport Point from './point'\nimport Range from './range'\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Annotation.\n *\n * @type {Annotation}\n */\n\nclass Annotation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Annotation` with `attrs`.\n   *\n   * @param {Object|Annotation} attrs\n   * @return {Annotation}\n   */\n\n  static create(attrs = {}) {\n    if (Annotation.isAnnotation(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Annotation.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Annotation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Annotation.create\\` only accepts objects or annotations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a map of annotations from `elements`.\n   *\n   * @param {Object<String,Annotation>|Map<String,Annotation>} elements\n   * @return {Map<String,Annotation>}\n   */\n\n  static createMap(elements = []) {\n    if (Map.isMap(elements)) {\n      return elements\n    }\n\n    if (isPlainObject(elements)) {\n      const obj = {}\n\n      for (const key in elements) {\n        const value = elements[key]\n        const annotation = Annotation.create(value)\n        obj[key] = annotation\n      }\n\n      return Map(obj)\n    }\n\n    throw new Error(\n      `\\`Annotation.createMap\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable annotation properties from `attrs`.\n   *\n   * @param {Object|String|Annotation} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Annotation.isAnnotation(a)) {\n      return {\n        key: a.key,\n        type: a.type,\n        data: a.data,\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('type' in a) p.type = a.type\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Annotation.createProperties\\` only accepts objects or annotations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Annotation` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Annotation}\n   */\n\n  static fromJSON(object) {\n    const { key, type, data, anchor, focus } = object\n\n    if (!key) {\n      throw new Error(\n        `Annotations must be created with a \\`key\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    if (!type) {\n      throw new Error(\n        `Annotations must be created with a \\`type\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const annotation = new Annotation({\n      key,\n      type,\n      data: Data.create(data || {}),\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return annotation\n  }\n\n  /**\n   * Set new `properties` on the annotation.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Annotation.createProperties(properties)\n    const annotation = this.merge(properties)\n    return annotation\n  }\n\n  /**\n   * Return a JSON representation of the annotation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      type: this.type,\n      data: this.data.toJSON(),\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Annotation}\n */\n\nexport default Annotation\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    invariant(\n      object.leaves == null,\n      'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.'\n    )\n\n    const { text = '', marks = [], key = KeyUtils.create() } = object\n    const node = new Text({\n      key,\n      text,\n      marks: Mark.createSet(marks),\n    })\n\n    return node\n  }\n\n  /**\n   * Check if `any` is a listof texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Add a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.add(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Add a set of `marks`.\n   *\n   * @param {Set<Mark>} marks\n   * @return {Text}\n   */\n\n  addMarks(marks) {\n    marks = Mark.createSet(marks)\n    const node = this.set('marks', this.marks.union(marks))\n    return node\n  }\n\n  /**\n   * Get a list of uniquely-formatted leaves for the text node, given its\n   * existing marks, and its current `annotations` and `decorations`.\n   *\n   * @param {List<Decoration>} decorations\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations) {\n    const { text, marks } = this\n    let leaves = [{ text, marks, decorations: [] }]\n\n    // Helper to split a leaf into two `at` an offset.\n    const split = (leaf, at) => {\n      return [\n        {\n          text: leaf.text.slice(0, at),\n          marks: leaf.marks,\n          decorations: [...leaf.decorations],\n        },\n        {\n          text: leaf.text.slice(at),\n          marks: leaf.marks,\n          decorations: [...leaf.decorations],\n        },\n      ]\n    }\n\n    const formats = decorations\n\n    for (const format of formats) {\n      const { start, end } = format\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the format.\n        if (start.offset <= offset && end.offset >= offset + length) {\n          leaf.decorations.push(format)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range starts after the leaf, or ends before it, continue.\n        if (\n          start.offset > offset + length ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the format to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < offset + length) {\n          ;[middle, after] = split(middle, end.offset - offset)\n        }\n\n        if (start.offset > offset) {\n          ;[before, middle] = split(middle, start.offset - offset)\n        }\n\n        middle.decorations.push(format)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Number} index\n   * @param {String} string\n   * @return {Text}\n   */\n\n  insertText(index, string) {\n    const { text } = this\n    const next = text.slice(0, index) + string + text.slice(index)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Remove a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.remove(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Remove text from the text node at `index` for `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(index, length) {\n    const { text } = this\n    const next = text.slice(0, index) + text.slice(index + length)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Set a `newProperties` on an existing `mark`.\n   *\n   * @param {Object} mark\n   * @param {Object} newProperties\n   * @return {Text}\n   */\n\n  setMark(properties, newProperties) {\n    const { marks } = this\n    const mark = Mark.create(properties)\n    const newMark = mark.merge(newProperties)\n    const next = marks.remove(mark).add(newMark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Split the node into two at `index`.\n   *\n   * @param {Number} index\n   * @returns {Array<Text>}\n   */\n\n  splitText(index) {\n    const { text } = this\n    const one = this.set('text', text.slice(0, index))\n    const two = this.set('text', text.slice(index)).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * Merge the node with an `other` text node.\n   *\n   * @param {Text} other\n   * @returns {Text}\n   */\n\n  mergeText(other) {\n    const next = this.text + other.text\n    const node = this.set('text', next)\n    return node\n  }\n}\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Text from './text'\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        warning(\n          false,\n          'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      let array = []\n\n      elements.forEach(el => {\n        if (\n          el &&\n          el.object === 'text' &&\n          el.leaves &&\n          Array.isArray(el.leaves)\n        ) {\n          warning(\n            false,\n            'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.'\n          )\n\n          const texts = Text.createList(el.leaves).toArray()\n          array = array.concat(texts)\n          return\n        }\n\n        const node = Node.create(el)\n        array.push(node)\n      })\n\n      const list = List(array)\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      warning(\n        false,\n        'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return (\n      Block.isBlock(any) ||\n      Document.isDocument(any) ||\n      Inline.isInline(any) ||\n      Text.isText(any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      data: Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { Record, Set, List } from 'immutable'\n\nimport Annotation from './annotation'\nimport Data from './data'\nimport Document from './document'\nimport Mark from './mark'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  annotations: undefined,\n  data: undefined,\n  document: undefined,\n  selection: undefined,\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        annotations: a.annotations,\n        data: a.data,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('annotations' in a)\n        p.annotations = Annotation.createMap(a.annotations)\n      if ('data' in a) p.data = Data.create(a.data)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { data = {}, annotations = {}, document = {}, selection = {} } = object\n    data = Data.fromJSON(data)\n    document = Document.fromJSON(document)\n    selection = document.createSelection(selection)\n    annotations = Annotation.createMap(annotations)\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.moveToStartOfNode(text)\n      selection = document.createSelection(selection)\n    }\n\n    const value = new Value({\n      annotations,\n      data,\n      document,\n      selection,\n    })\n\n    return value\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestBlock(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestBlock(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestInline(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestInline(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return (\n      this.selection.start.key &&\n      this.document.getDescendant(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return (\n      this.selection.end.key &&\n      this.document.getDescendant(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getDescendant(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return (\n      this.selection.focus.key &&\n      this.document.getDescendant(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextText(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousText(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the bottom-most inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Add an `annotation` to the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    let value = this\n    let { annotations, document } = value\n    const { key } = annotation\n    annotation = annotation.updatePoints(point => point.normalize(document))\n    annotations = annotations.set(key, annotation)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.addMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  insertText(path, offset, text) {\n    let value = this\n    let { document } = value\n    let node = document.assertNode(path)\n    document = document.insertText(path, offset, text)\n    node = document.assertNode(path)\n    value = value.set('document', document)\n\n    value = value.mapPoints(point => {\n      if (point.key === node.key && point.offset >= offset) {\n        return point.setOffset(\n          Math.min(node.text.length, point.offset + text.length)\n        )\n      } else {\n        return point\n      }\n    }, true)\n\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchor.key === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchor.offset)\n        }\n\n        if (range.focus.key === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focus.offset)\n        }\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n\n    if (PathUtils.isEqual(path, newPath)) {\n      return value\n    }\n\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n    value = value.mapPoints(point => point.setPath(null))\n    return value\n  }\n\n  /**\n   * Remove an `annotation` from the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    let value = this\n    let { annotations } = value\n    const { key } = annotation\n    annotations = annotations.delete(key)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Remove `mark` at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object === 'text' ? node : node.getFirstText() || node\n    const last = node.object === 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { anchor, focus } = range\n\n      if (node.hasNode(anchor.key)) {\n        range = prev\n          ? range.moveAnchorTo(prev.key, prev.text.length)\n          : next ? range.moveAnchorTo(next.key, 0) : range.unset()\n      }\n\n      if (node.hasNode(focus.key)) {\n        range = prev\n          ? range.moveFocusTo(prev.key, prev.text.length)\n          : next ? range.moveFocusTo(next.key, 0) : range.unset()\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const { length } = text\n    const start = offset\n    const end = offset + length\n\n    value = value.mapPoints(point => {\n      if (point.key !== node.key) {\n        return point\n      }\n\n      if (point.offset >= end) {\n        return point.setOffset(point.offset - length)\n      }\n\n      if (point.offset > start) {\n        return point.setOffset(start)\n      }\n\n      return point\n    })\n\n    return value\n  }\n\n  /**\n   * Add an `annotation` to the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  setAnnotation(properties, newProperties) {\n    newProperties = Annotation.createProperties(newProperties)\n    const annotation = Annotation.create(properties)\n    const next = annotation.merge(newProperties)\n    let value = this\n    let { annotations } = value\n    const { key } = annotation\n    annotations = annotations.set(key, next)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the value.\n   *\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setProperties(properties) {\n    let value = this\n    const { document } = value\n    const { data, annotations } = properties\n    const props = {}\n\n    if (data) {\n      props.data = data\n    }\n\n    if (annotations) {\n      props.annotations = annotations.map(a => {\n        return a.isSet ? a : document.resolveAnnotation(a)\n      })\n    }\n\n    value = value.merge(props)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    const next = selection.setProperties(properties)\n    selection = document.resolveSelection(next)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { anchor, focus } = range\n\n      // If the anchor was after the split, move it to the next node.\n      if (node.key === anchor.key && position <= anchor.offset) {\n        range = range.moveAnchorTo(next.key, anchor.offset - position)\n      }\n\n      // If the focus was after the split, move it to the next node.\n      if (node.key === focus.key && position <= focus.offset) {\n        range = range.moveFocusTo(next.key, focus.offset - position)\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator, skipNormalize) {\n    let value = this\n    const { document, selection: oldSelection, annotations } = value\n\n    let newSelection = oldSelection.isSet\n      ? iterator(oldSelection)\n      : oldSelection\n    if (!newSelection) newSelection = oldSelection.unset()\n    if (newSelection !== oldSelection && !skipNormalize)\n      newSelection = document.createSelection(newSelection)\n    value = value.set('selection', newSelection)\n\n    let anns = annotations.map(annotation => {\n      let n = annotation.isSet ? iterator(annotation) : annotation\n      if (n && n !== annotation) n = document.createAnnotation(n)\n      return n\n    })\n\n    anns = anns.filter(annotation => !!annotation)\n    value = value.set('annotations', anns)\n    return value\n  }\n\n  mapPoints(iterator, skipNormalize) {\n    return this.mapRanges(range => range.updatePoints(iterator), skipNormalize)\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveAnnotations) {\n      object.annotations = this.annotations\n        .map(a => a.toJSON(options))\n        .toObject()\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    return object\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get history() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.'\n    )\n  }\n\n  change() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.'\n    )\n  }\n}\n\n/**\n * Export.\n */\n\nexport default Value\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  // prettier-ignore\n  if (window.ENABLE_SLATE_LOGGING) console.log(`    apply_operation: ${type} ${(JSON.stringify(op.toJSON().properties) || '').substring(0, 100)}`)\n\n  switch (type) {\n    case 'add_annotation': {\n      const { annotation } = op\n      const next = value.addAnnotation(annotation)\n      return next\n    }\n\n    case 'add_mark': {\n      const { path, mark } = op\n      const next = value.addMark(path, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_annotation': {\n      const { annotation } = op\n      const next = value.removeAnnotation(annotation)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, mark } = op\n      const next = value.removeMark(path, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_annotation': {\n      const { properties, newProperties } = op\n      const next = value.setAnnotation(properties, newProperties)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, properties, newProperties } = op\n      const next = value.setMark(path, properties, newProperties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, newProperties } = op\n      const next = value.setNode(path, newProperties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n      const next = value.setSelection(newProperties)\n      return next\n    }\n\n    case 'set_value': {\n      const { newProperties } = op\n      const next = value.setProperties(newProperties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'move_node': {\n      const { newPath, path } = op\n\n      // PERF: this case can exit early.\n      if (PathUtils.isEqual(newPath, path)) {\n        return op\n      }\n\n      const inversePath = PathUtils.transform(path, op).first()\n\n      // Get the true path we are trying to move back to\n      // We transform the right-sibling of the path\n      // This will end up at the operation.path most of the time\n      // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n      const inverseNewPath = PathUtils.transform(\n        PathUtils.increment(path),\n        op\n      ).first()\n\n      const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_annotation':\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark': {\n      const { properties, newProperties } = op\n      const inverse = op\n        .set('properties', newProperties)\n        .set('newProperties', properties)\n      return inverse\n    }\n\n    case 'insert_node':\n    case 'insert_text': {\n      const inverse = op.set('type', type.replace('insert_', 'remove_'))\n      return inverse\n    }\n\n    case 'remove_node':\n    case 'remove_text': {\n      const inverse = op.set('type', type.replace('remove_', 'insert_'))\n      return inverse\n    }\n\n    case 'add_annotation':\n    case 'add_mark': {\n      const inverse = op.set('type', type.replace('add_', 'remove_'))\n      return inverse\n    }\n\n    case 'remove_annotation':\n    case 'remove_mark': {\n      const inverse = op.set('type', type.replace('remove_', 'add_'))\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Map } from 'immutable'\n\nimport Annotation from './annotation'\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Selection from './selection'\nimport Value from './value'\nimport apply from '../operations/apply'\nimport invert from '../operations/invert'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  add_annotation: ['annotation', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_annotation: ['annotation', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_annotation: ['properties', 'newProperties', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  annotation: undefined,\n  data: undefined,\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  newProperties: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      // Default `data` to an empty object.\n      if (key === 'data' && v === undefined) {\n        v = {}\n      }\n\n      if (v === undefined) {\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'annotation') {\n        v = Annotation.create(v)\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_annotation'\n      ) {\n        v = Annotation.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        v = Mark.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        (type === 'set_node' || type === 'merge_node' || type === 'split_node')\n      ) {\n        v = Node.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        v = Selection.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'data') {\n        v = Map(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const op = new Operation(attrs)\n    return op\n  }\n\n  /**\n   * Check if `any` is a listof operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Apply the operation to a `value`.\n   *\n   * @param {Value} value\n   * @return {Value}\n   */\n\n  apply(value) {\n    const next = apply(value, this)\n    return next\n  }\n\n  /**\n   * Invert the operation.\n   *\n   * @return {Operation}\n   */\n\n  invert() {\n    const inverted = invert(this)\n    return inverted\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      if (\n        key === 'annotation' ||\n        key === 'mark' ||\n        key === 'marks' ||\n        key === 'node' ||\n        key === 'path' ||\n        key === 'newPath'\n      ) {\n        value = value.toJSON()\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_annotation'\n      ) {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJS()\n        if ('focus' in value) v.focus = value.focus.toJS()\n        if ('key' in value) v.key = value.key\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_node'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJSON()\n        if ('focus' in value) v.focus = value.focus.toJSON()\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        value = v\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key === 'data') {\n        value = value.toJSON()\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n}\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import isPlainObject from 'is-plain-object'\nimport { Record } from 'immutable'\n\nimport Operation from './operation'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  operations: undefined,\n  value: undefined,\n}\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change extends Record(DEFAULTS) {\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object|Change} attrs\n   * @return {Change}\n   */\n\n  static create(attrs = {}) {\n    if (Change.isChange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Change.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Change.create\\` only accepts objects or changes, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Change` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Change}\n   */\n\n  static fromJSON(object) {\n    const { value, operations = [] } = object\n\n    const change = new Change({\n      value: Value.create(value),\n      operations: Operation.createList(operations),\n    })\n\n    return change\n  }\n\n  /**\n   * Return a JSON representation of the change.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      value: this.value.toJSON(options),\n      operations: this.operations.toArray().map(o => o.toJSON(options)),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\nfunction CommandsPlugin(commands = {}) {\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    const { type, args } = command\n    const fn = commands[type]\n    if (!fn) return next()\n    editor.command(fn, ...args)\n  }\n\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const command in commands) {\n      editor.registerCommand(command)\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onCommand,\n    onConstruct,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CommandsPlugin\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n *\n * @param {Number} code\n * @param {String} text\n * @param {Number} offset\n * @return {Boolean}\n */\n\nfunction isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart ()\n    code === 0x2642 || // male ()\n    code === 0x2640 || // female ()\n    code === 0x2620 || // scull ()\n    code === 0x2695 || // medical ()\n    code === 0x2708 || // plane ()\n    code === 0x25ef // large circle ()\n  )\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the character(s) in `text`.\n * This function is emoji aware and handles them correctly.\n *\n * @param {String} text\n * @param {Number} chars\n * @param {Boolean} forward\n * @return {Number}\n */\n\nfunction getCharOffset(text, chars, forward) {\n  let offset = 0\n\n  // Handle end/beginning of node: we have to return 1 in order not to\n  // break cursor's jumping to next/previous node. We need to return early\n  // because otherwise, ''.charCodeAt(0) returned NaN and, the default\n  // handling 'latin characters' at the end of the while loop would\n  // would never be reached an we returned '0' as offset.\n  if (text === '') return 1\n\n  // Calculate offset sum of each character\n  for (let i = 0; i < chars; i++) {\n    // `prev` types (better ideas?):\n    // - SURR: surrogate pair\n    // - MOD: modifier (technically also surrogate pair)\n    // - ZWJ: zero width joiner\n    // - VAR: variation selector\n    // - BMP: sequenceable character from Basic Multilingual Plane\n    let prev = null\n    let charCode = text.charCodeAt(offset)\n\n    while (charCode) {\n      if (isSurrogate(charCode)) {\n        const modifier = isModifier(charCode, text, offset)\n\n        // Early returns are the heart of this loop where\n        // we decide if previous and current codepoints\n        // should form a single character (in other words:\n        // how many of them should selection jump over).\n        if (forward) {\n          if (\n            (!modifier && prev && prev !== 'ZWJ') ||\n            (modifier && prev && prev !== 'SURR')\n          ) {\n            break\n          }\n        } else if (prev === 'SURR' || prev === 'BMP') {\n          break\n        }\n\n        offset += 2\n        prev = modifier ? 'MOD' : 'SURR'\n        charCode = text.charCodeAt(offset)\n        // It's okay to `continue` without checking\n        // because if `charCode` is NaN (which is\n        // the case when out of `text` range), next\n        // `while` loop won't execute and we're done.\n        continue\n      }\n\n      // If zero width joiner\n      if (charCode === 0x200d) {\n        offset += 1\n        prev = 'ZWJ'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      if (isBMPEmoji(charCode)) {\n        if (\n          (forward && prev === 'VAR') ||\n          (prev && prev !== 'ZWJ' && prev !== 'VAR')\n        ) {\n          break\n        }\n\n        offset += 1\n        prev = 'BMP'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      if (isVariationSelector(charCode)) {\n        if (!forward && prev && prev !== 'ZWJ') {\n          break\n        }\n\n        offset += 1\n        prev = 'VAR'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      // Modifier \"fuses\" with what ever character is before that\n      // (even whitespace), need to look ahead if loop gets here.\n      if (forward) {\n        const nextCharCode = text.charCodeAt(offset + 1)\n\n        if (isModifier(nextCharCode, text, offset + 1)) {\n          offset += 3\n          prev = 'MOD'\n          charCode = text.charCodeAt(offset)\n          continue\n        }\n      } else if (prev === 'MOD') {\n        offset += 1\n        break\n      }\n\n      // If while loop ever gets here, we're\n      // done (e.g Latin characters, length 1).\n      if (prev === null) offset += 1\n      break\n    }\n  }\n\n  return offset\n}\n\n/**\n * Get the offset to the end of character(s) before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset, chars = 1) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text, chars)\n}\n\n/**\n * Get the offset to the end of character(s) after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset, chars = 1) {\n  text = text.slice(offset)\n  return getCharOffset(text, chars, true)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n\n  if (document.hasDescendant(start.path)) {\n    range = range.moveToStart()\n  } else {\n    range = range.moveTo(end.path, 0).normalize(document)\n  }\n\n  return range\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.addMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n  const texts = document.getTextsAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.addMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\nCommands.addMarksAtRange = (editor, range, marks) => {\n  marks.forEach(mark => editor.addMarkAtRange(range, mark))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteAtRange = (editor, range) => {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection()\n\n  const { value } = editor\n  const { start, end } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  let endKey = end.key\n  let endOffset = end.offset\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey, editor)\n  let isEndVoid = document.hasVoidParent(endKey, editor)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  if (startKey == null && endKey == null) return\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset === 0 &&\n    endOffset === 0 &&\n    isStartVoid === false &&\n    startKey === startBlock.getFirstText().key &&\n    endKey === endBlock.getFirstText().key &&\n    startKey !== endKey\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, editor)\n  }\n\n  editor.withoutNormalizing(() => {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      const startVoid = document.getClosestVoid(startKey, editor)\n      const nextText = document.getNextText(startKey)\n      editor.removeNodeByKey(startVoid.key)\n\n      // If the start and end keys are the same, we're done.\n      if (startKey === endKey) return\n\n      // If there is no next text node, we're done.\n      if (!nextText) return\n\n      // Continue...\n      document = editor.value.document\n      startKey = nextText.key\n      startOffset = 0\n      isStartVoid = document.hasVoidParent(startKey, editor)\n    }\n\n    // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n    while (isEndVoid) {\n      const endVoid = document.getClosestVoid(endKey, editor)\n      const prevText = document.getPreviousText(endKey)\n      editor.removeNodeByKey(endVoid.key)\n\n      // Continue...\n      document = editor.value.document\n      endKey = prevText.key\n      endOffset = prevText.text.length\n      isEndVoid = document.hasVoidParent(endKey, editor)\n    }\n\n    // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key)\n      return\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      const index = startOffset\n      const length = endOffset - startOffset\n      editor.removeTextByKey(startKey, index, length)\n      return\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey)\n      endBlock = document.getClosestBlock(endKey)\n      const startText = document.getNode(startKey)\n      const endText = document.getNode(endKey)\n      const startLength = startText.text.length - startOffset\n      const endLength = endOffset\n\n      const ancestor = document.getCommonAncestor(startKey, endKey)\n      const startChild = ancestor.getFurthestChild(startKey)\n      const endChild = ancestor.getFurthestChild(endKey)\n\n      const startParent = document.getParent(startBlock.key)\n      const startParentIndex = startParent.nodes.indexOf(startBlock)\n      const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n      let child\n\n      // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n      child = startText\n\n      while (child.key !== startChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const afters = parent.nodes.slice(index + 1)\n\n        afters.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove all of the middle children.\n      const startChildIndex = ancestor.nodes.indexOf(startChild)\n      const endChildIndex = ancestor.nodes.indexOf(endChild)\n      const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n      middles.reverse().forEach(node => {\n        editor.removeNodeByKey(node.key)\n      })\n\n      // Remove the nodes before the end text node in the tree.\n      child = endText\n\n      while (child.key !== endChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const befores = parent.nodes.slice(0, index)\n\n        befores.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove any overlapping text content from the leaf text nodes.\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength)\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset)\n      }\n\n      // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document\n        let onlyChildAncestor\n\n        for (const [node] of document.ancestors(endBlock.key)) {\n          if (node.nodes.size > 1) {\n            break\n          } else {\n            onlyChildAncestor = node\n          }\n        }\n\n        // Move the end block to be right after the start block.\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(\n            endBlock.key,\n            startParent.key,\n            startParentIndex + 1\n          )\n        }\n\n        // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key)\n        } else {\n          editor.mergeNodeByKey(endBlock.key)\n        }\n\n        // If nested empty blocks are left over above the end block, remove them.\n        if (onlyChildAncestor) {\n          editor.removeNodeByKey(onlyChildAncestor.key)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.path, editor)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return\n  }\n\n  const block = document.getClosestBlock(start.path)\n\n  // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n  if (\n    document.nodes.size !== 1 &&\n    block &&\n    block.text === '' &&\n    block.nodes.size === 1\n  ) {\n    editor.removeNodeByKey(block.key)\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.path)\n\n  if (start.isAtStartOfNode(text)) {\n    let prev = document.getPreviousText(text.key)\n    const inline = document.getClosestInline(text.key)\n\n    // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key)\n    }\n\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key, editor)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n <= focus.offset) {\n    range = range.moveFocusBackward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focus.offset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    if (node == null) return\n\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  let startBlock = document.getClosestBlock(start.path)\n\n  if (startBlock == null) {\n    const node = document.getNode(start.path)\n\n    if (\n      (node != null && node.object === 'block') ||\n      node.object === 'document'\n    ) {\n      startBlock = node\n    }\n  }\n\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteForwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.path, editor)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  const block = document.getClosestBlock(start.path)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !editor.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    const nextBlock = document.getNextBlock(block.key)\n    editor.removeNodeByKey(block.key)\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock)\n    }\n\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.path)\n\n  if (start.isAtEndOfNode(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key, editor)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focus.offset\n  let traversed = text.text.length - focus.offset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    if (node == null) return\n\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteBackwardAtRange(range, o)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteForwardAtRange(range, startBlock.text.length - o)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const wordOffset = TextUtils.getWordOffsetForward(text, o)\n  const n = wordOffset === 0 ? 1 : wordOffset\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\nCommands.insertBlockAtRange = (editor, range, block) => {\n  range = deleteExpandedAtRange(editor, range)\n  block = Block.create(block)\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const insertionMode = getInsertionMode(editor, range)\n\n  if (insertionMode === 'before') {\n    editor.insertNodeByKey(parent.key, index, block)\n  } else if (insertionMode === 'behind') {\n    editor.insertNodeByKey(parent.key, index + 1, block)\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      const atEnd = start.isAtEndOfNode(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOfNode(siblingText)\n        : range.moveToEndOfNode(siblingText)\n\n      startKey = splitRange.start.key\n      startOffset = splitRange.start.offset\n    }\n\n    editor.withoutNormalizing(() => {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset)\n      editor.insertNodeByKey(parent.key, index + 1, block)\n    })\n  }\n}\n\n/**\n * Check if current block should be split or new block should be added before or behind it.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nconst getInsertionMode = (editor, range) => {\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startKey = start.key\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n\n  if (editor.isVoid(startBlock)) {\n    if (start.isAtEndOfNode(startBlock)) return 'behind'\n    else return 'before'\n  } else if (!startInline && startBlock.text === '') {\n    return 'behind'\n  } else if (start.isAtStartOfNode(startBlock)) {\n    return 'before'\n  } else if (start.isAtEndOfNode(startBlock)) {\n    return 'behind'\n  }\n  return 'split'\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\nCommands.insertFragmentAtRange = (editor, range, fragment) => {\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    // If the fragment is empty, there's nothing to do after deleting.\n    if (!fragment.nodes.size) return\n\n    // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be regenerated automatically and we won't have an easy way to\n    // reference them.\n    fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n    // Calculate a few things...\n    const { start } = range\n    const { value } = editor\n    let { document } = value\n    let startText = document.getDescendant(start.path)\n    let startBlock = document.getClosestBlock(startText.key)\n    let startChild = startBlock.getFurthestChild(startText.key)\n    const isAtStart = start.isAtStartOfNode(startBlock)\n    const parent = document.getParent(startBlock.key)\n    const index = parent.nodes.indexOf(startBlock)\n    const blocks = fragment.getBlocks()\n    const firstChild = fragment.nodes.first()\n    const lastChild = fragment.nodes.last()\n    const firstBlock = blocks.first()\n    const lastBlock = blocks.last()\n    const insertionNode = findInsertionNode(fragment, document, startBlock.key)\n\n    // If the fragment only contains a void block, use `insertBlock` instead.\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock)\n      return\n    }\n\n    // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n    if (\n      insertionNode === fragment &&\n      (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())\n    ) {\n      // check if reversal is necessary or not\n      const insertionMode = getInsertionMode(editor, range)\n      const nodes =\n        insertionMode === 'before' ? fragment.nodes : fragment.nodes.reverse()\n\n      nodes.forEach(node => {\n        editor.insertBlockAtRange(range, node)\n      })\n      return\n    }\n\n    // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n    if (firstBlock !== lastBlock) {\n      const lonelyParent = insertionNode.getFurthest(\n        firstBlock.key,\n        p => p.nodes.size === 1\n      )\n      const lonelyChild = lonelyParent || firstBlock\n\n      const startIndex = parent.nodes.indexOf(startBlock)\n      const excludingLonelyChild = insertionNode.removeNode(lonelyChild.key)\n\n      excludingLonelyChild.nodes.forEach((node, i) => {\n        const newIndex = startIndex + i + 1\n        editor.insertNodeByKey(parent.key, newIndex, node)\n      })\n    }\n\n    // Check if we need to split the node.\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    // Update our variables with the new value.\n    document = editor.value.document\n    startText = document.getDescendant(start.key)\n    startBlock = document.getClosestBlock(start.key)\n    startChild = startBlock.getFurthestChild(startText.key)\n\n    // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n    if (firstBlock !== lastBlock) {\n      const nextChild = isAtStart\n        ? startChild\n        : startBlock.getNextSibling(startChild.key)\n      const nextNodes = nextChild\n        ? startBlock.nodes.skipUntil(n => n.key === nextChild.key)\n        : List()\n      const lastIndex = lastBlock.nodes.size\n\n      nextNodes.forEach((node, i) => {\n        const newIndex = lastIndex + i\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex)\n      })\n    }\n\n    // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n    if (\n      !editor.isVoid(startBlock) &&\n      startBlock.text === '' &&\n      !startBlock.findDescendant(n => editor.isVoid(n))\n    ) {\n      editor.removeNodeByKey(startBlock.key)\n      editor.insertNodeByKey(parent.key, index, firstBlock)\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      const inlineChild = startBlock.getFurthestChild(startText.key)\n      const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n      firstBlock.nodes.forEach((inline, i) => {\n        const o = start.offset === 0 ? 0 : 1\n        const newIndex = inlineIndex + i + o\n        editor.insertNodeByKey(startBlock.key, newIndex, inline)\n      })\n    }\n  })\n}\n\n/**\n * Get the deepest single child block inside `fragment` whose reversed block\n * ancestors match the reversed block ancestors of the `document` starting at\n * the `documentKey`.\n *\n * @param {Document} document\n * @param {string} documentKey\n * @param {Document} fragment\n * @return {Node}\n */\n\nconst findInsertionNode = (fragment, document, documentKey) => {\n  // Find the deepest block in a doc with no siblings.\n  const deepestSingleBlock = doc => {\n    let result = doc\n\n    while (result.nodes.size === 1 && result.nodes.first().object === 'block') {\n      result = result.nodes.first()\n    }\n\n    return result === doc ? null : result\n  }\n\n  // Return whether every block in the `fragmentAncestors` list has the\n  // same type as the block in `documentAncestors` with the same index.\n  const ancestorTypesMatch = (fragmentAncestors, documentAncestors) => {\n    return (\n      documentAncestors.size >= fragmentAncestors.size &&\n      fragmentAncestors.every((fragmentNode, i) => {\n        return documentAncestors.get(i).type === fragmentNode.type\n      })\n    )\n  }\n\n  // Given two reverse lists of ancestors, check if all fragment ancestor types\n  // match the doc ancestors at some position.\n  const matchingFragmentAncestor = (documentAncestors, fragmentAncestors) => {\n    const depthDifference = documentAncestors.size - fragmentAncestors.size\n\n    // There is nothing to align if the fragment is deeper than the document.\n    if (depthDifference < 0) {\n      return fragment\n    }\n\n    for (let fragIdx = 0; fragIdx < fragmentAncestors.size; fragIdx++) {\n      // The docIdx loop relaxes our check in that we can still match if there\n      // are node type differences leaf-side.\n      // This is important for example if our fragment inserts multiple siblings\n      // or inserts another type while the tree structure remains the same.\n      for (let docIdx = 0; docIdx <= depthDifference; docIdx++) {\n        if (\n          ancestorTypesMatch(\n            fragmentAncestors.slice(fragIdx),\n            documentAncestors.slice(docIdx)\n          )\n        ) {\n          return fragmentAncestors.get(fragIdx)\n        }\n      }\n    }\n    return fragment\n  }\n\n  // Get the type definitions for all ancestors up from node with key `key`,\n  // except the document object.\n  const getAncestorBlocks = (doc, key) => {\n    return doc\n      .getAncestors(key)\n      .slice(1)\n      .push(doc.getNode(key))\n      .reverse()\n  }\n\n  const fragmentStartBlock = deepestSingleBlock(fragment)\n\n  if (!fragmentStartBlock) {\n    return fragment\n  }\n\n  const documentAncestors = getAncestorBlocks(document, documentKey)\n  const fragmentAncestors = getAncestorBlocks(fragment, fragmentStartBlock.key)\n\n  return matchingFragmentAncestor(documentAncestors, fragmentAncestors)\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\nCommands.insertInlineAtRange = (editor, range, inline) => {\n  inline = Inline.create(inline)\n\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    const { value } = editor\n    const { document } = value\n    const { start } = range\n    const parent = document.getParent(start.path)\n    const startText = document.assertDescendant(start.path)\n    const index = parent.nodes.indexOf(startText)\n\n    if (editor.isVoid(parent)) {\n      return\n    }\n\n    editor.splitNodeByPath(start.path, start.offset)\n    editor.insertNodeByKey(parent.key, index + 1, inline)\n  })\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextAtRange = (editor, range, text, marks) => {\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    const { value } = editor\n    const { document } = value\n    const { start } = range\n    const offset = start.offset\n    const parent = document.getParent(start.path)\n\n    if (editor.isVoid(parent)) {\n      return\n    }\n\n    editor.insertTextByPath(start.path, offset, text, marks)\n  })\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\nCommands.removeMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { start, end } = range\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.removeMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setBlocksAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n\n  const { start, end, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(start.path, editor)\n  const startBlock = document.getClosestBlock(start.path)\n  const endBlock = document.getClosestBlock(end.key)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed === false &&\n    start.offset === 0 &&\n    end.offset === 0 &&\n    isStartVoid === false &&\n    start.key === startBlock.getFirstText().key &&\n    end.key === endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  editor.withoutNormalizing(() => {\n    sets.forEach(block => {\n      editor.setNodeByKey(block.key, properties)\n    })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setInlinesAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const inlines = document.getLeafInlinesAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      editor.setNodeByKey(inline.key, properties)\n    })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitBlockAtRange = (editor, range, height = 1) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start, end } = range\n  let { value } = editor\n  let { document } = value\n  let node = document.assertDescendant(start.path)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.splitDescendantsByKey(node.key, start.path, start.offset)\n\n    value = editor.value\n    document = value.document\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip()\n      const nextBlock = document.getNextBlock(node.key)\n      range = range.moveAnchorToStartOfNode(nextBlock)\n      range = range.setFocus(range.focus.setPath(null))\n\n      if (start.path.equals(end.path)) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset)\n      }\n\n      range = document.resolveRange(range)\n      editor.deleteAtRange(range)\n    }\n  })\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitInlineAtRange = (editor, range, height = Infinity) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start } = range\n  const { value } = editor\n  const { document } = value\n  let node = document.assertDescendant(start.path)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  editor.splitDescendantsByKey(node.key, start.path, start.offset)\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.toggleMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const { value } = editor\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark)\n  } else {\n    editor.addMarkAtRange(range, mark)\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlockAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  let { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object !== 'block') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    wrappers.forEach(block => {\n      const first = block.nodes.first()\n      const last = block.nodes.last()\n      const parent = editor.value.document.getParent(block.key)\n      const index = parent.nodes.indexOf(block)\n\n      const children = block.nodes.filter(child => {\n        return blocks.some(b => child === b || child.hasDescendant(b.key))\n      })\n\n      const firstMatch = children.first()\n      const lastMatch = children.last()\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + i)\n        })\n\n        editor.removeNodeByKey(block.key)\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(n => n === firstMatch).forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      } else if (first === firstMatch) {\n        block.nodes\n          .takeUntil(n => n === lastMatch)\n          .push(lastMatch)\n          .forEach((child, i) => {\n            editor.moveNodeByKey(child.key, parent.key, index + i)\n          })\n      } else {\n        const firstText = firstMatch.getFirstText()\n\n        editor.splitDescendantsByKey(block.key, firstText.key, 0)\n\n        document = editor.value.document\n\n        children.forEach((child, i) => {\n          if (i === 0) {\n            const extra = child\n            child = document.getNextBlock(child.key)\n            editor.removeNodeByKey(extra.key)\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      }\n    })\n  })\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapInlineAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object !== 'inline') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      const parent = editor.value.document.getParent(inline.key)\n      const index = parent.nodes.indexOf(inline)\n\n      inline.nodes.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, parent.key, index + i)\n      })\n\n      editor.removeNodeByKey(inline.key)\n    })\n  })\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockAtRange = (editor, range, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { value } = editor\n  const { document } = value\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 === p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  editor.withoutNormalizing(() => {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block)\n\n    // Move the sibling nodes into the new block node.\n    siblings.forEach((node, i) => {\n      editor.moveNodeByKey(node.key, block.key, i)\n    })\n  })\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInlineAtRange = (editor, range, inline) => {\n  const { value } = editor\n  let { document } = value\n  const { start, end } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(start.path)\n\n    if (!inlineParent) {\n      return\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(start.path)\n  let endBlock = document.getClosestBlock(end.path)\n  const startInline = document.getClosestInline(start.path)\n  const endInline = document.getClosestInline(end.path)\n  let startChild = startBlock.getFurthestChild(start.key)\n  let endChild = endBlock.getFurthestChild(end.key)\n\n  editor.withoutNormalizing(() => {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset)\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    document = editor.value.document\n    startBlock = document.getDescendant(startBlock.key)\n    endBlock = document.getDescendant(endBlock.key)\n    startChild = startBlock.getFurthestChild(start.key)\n    endChild = endBlock.getFurthestChild(end.key)\n    const startIndex = startBlock.nodes.indexOf(startChild)\n    const endIndex = endBlock.nodes.indexOf(endChild)\n\n    if (startInline && startInline === endInline) {\n      const texts = startBlock.getTextsAtRange(range).map(text => {\n        if (start.key === text.key && end.key === text.key) {\n          return text\n            .splitText(start.offset)[1]\n            .splitText(end.offset - start.offset)[0]\n            .regenerateKey()\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey()\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey()\n        } else {\n          return text.regenerateKey()\n        }\n      })\n\n      inline = inline.set('nodes', texts)\n      editor.insertInlineAtRange(range, inline)\n    } else if (startBlock === endBlock) {\n      document = editor.value.document\n      startBlock = document.getClosestBlock(start.key)\n      startChild = startBlock.getFurthestChild(start.key)\n\n      const startInner = document.getNextSibling(startChild.key)\n      const startInnerIndex = startBlock.nodes.indexOf(startInner)\n      const endInner =\n        start.key === end.key\n          ? startInner\n          : startBlock.getFurthestChild(end.key)\n      const inlines = startBlock.nodes\n        .skipUntil(n => n === startInner)\n        .takeUntil(n => n === endInner)\n        .push(endInner)\n\n      const node = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node)\n\n      inlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, node.key, i)\n      })\n    } else {\n      const startInlines = startBlock.nodes.slice(startIndex + 1)\n      const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n      const startNode = inline.regenerateKey()\n      const endNode = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode)\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode)\n\n      startInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, startNode.key, i)\n      })\n\n      endInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, endNode.key, i)\n      })\n\n      blocks.slice(1, -1).forEach(block => {\n        const node = inline.regenerateKey()\n        editor.insertNodeByKey(block.key, 0, node)\n\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, node.key, i)\n        })\n      })\n    }\n  })\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\nCommands.wrapTextAtRange = (editor, range, prefix, suffix = prefix) => {\n  const { start, end } = range\n  const startRange = range.moveToStart()\n  let endRange = range.moveToEnd()\n\n  if (start.path.equals(end.path)) {\n    endRange = endRange.moveForward(prefix.length)\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(startRange, prefix)\n    editor.insertTextAtRange(endRange, suffix)\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands.addMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.addMarksByPath(path, offset, length, [mark])\n}\n\nCommands.addMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'add_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n  })\n}\n\n/**\n * Sets specific set of marks on the path\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Array<Object|Mark>} marks\n */\n\nCommands.replaceMarksByPath = (editor, path, offset, length, marks) => {\n  const marksSet = Mark.createSet(marks)\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  if (node.marks.equals(marksSet)) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    const marksToApply = marksSet.subtract(node.marks)\n    const marksToRemove = node.marks.subtract(marksSet)\n\n    marksToRemove.forEach(mark => {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n\n    marksToApply.forEach(mark => {\n      editor.applyOperation({\n        type: 'add_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n  })\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\nCommands.insertFragmentByPath = (editor, path, index, fragment) => {\n  fragment.nodes.forEach((node, i) => {\n    editor.insertNodeByPath(path, index + i, node)\n  })\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nCommands.insertNodeByPath = (editor, path, index, node) => {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextByPath = (editor, path, offset, text, marks) => {\n  const { value } = editor\n  const { annotations, document } = value\n  document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    for (const annotation of annotations.values()) {\n      const { start, end } = annotation\n      const isAtomic = editor.isAtomic(annotation)\n\n      if (!isAtomic) {\n        continue\n      }\n\n      if (!start.path.equals(path)) {\n        continue\n      }\n\n      if (\n        start.offset < offset &&\n        (!end.path.equals(path) || end.offset > offset)\n      ) {\n        editor.removeAnnotation(annotation)\n      }\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path,\n      offset,\n      text,\n    })\n\n    if (marks) {\n      editor.replaceMarksByPath(path, offset, text.length, marks)\n    }\n  })\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.mergeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object === 'text' ? previous.text.length : previous.nodes.size\n\n  editor.applyOperation({\n    type: 'merge_node',\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n}\n\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\nCommands.moveNodeByPath = (editor, path, newParentPath, newIndex) => {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor\n  }\n\n  const newPath = newParentPath.concat(newIndex)\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path,\n    newPath,\n  })\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands.removeMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.removeMarksByPath(path, offset, length, [mark])\n}\n\nCommands.removeMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  if (marks.intersect(node.marks).isEmpty()) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path,\n        offset,\n        length,\n        mark,\n      })\n    })\n  })\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeAllMarksByPath = (editor, path) => {\n  const { state } = editor\n  const { document } = state\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    if (node.object === 'text') {\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks)\n      return\n    }\n\n    for (const [n, p] of node.texts()) {\n      const pth = path.concat(p)\n      editor.removeMarksByPath(pth, 0, n.text.length, n.marks)\n    }\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.applyOperation({\n    type: 'remove_node',\n    path,\n    node,\n  })\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nCommands.removeTextByPath = (editor, path, offset, length) => {\n  const { value } = editor\n  const { document, annotations } = value\n  const node = document.assertNode(path)\n  const text = node.text.slice(offset, offset + length)\n\n  editor.withoutNormalizing(() => {\n    for (const annotation of annotations.values()) {\n      const { start, end } = annotation\n      const isAtomic = editor.isAtomic(annotation)\n\n      if (!isAtomic) {\n        continue\n      }\n\n      if (!start.path.equals(path)) {\n        continue\n      }\n\n      if (\n        start.offset < offset &&\n        (!end.path.equals(path) || end.offset > offset)\n      ) {\n        editor.removeAnnotation(annotation)\n      }\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path,\n      offset,\n      text,\n    })\n  })\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\nCommands.replaceNodeByPath = (editor, path, newNode) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n\n  editor.withoutNormalizing(() => {\n    editor.removeNodeByPath(path)\n    editor.insertNodeByPath(parentPath, index, newNode)\n  })\n}\n\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.replaceTextByPath = (editor, path, offset, length, text, marks) => {\n  editor.withoutNormalizing(() => {\n    editor.removeTextByPath(path, offset, length)\n    editor.insertTextByPath(path, offset, text, marks)\n  })\n}\n\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\nCommands.setMarkByPath = (\n  editor,\n  path,\n  offset,\n  length,\n  properties,\n  newProperties\n) => {\n  properties = Mark.create(properties)\n  newProperties = Mark.createProperties(newProperties)\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path,\n      properties,\n      newProperties,\n    })\n  })\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\nCommands.setNodeByPath = (editor, path, newProperties) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  newProperties = Node.createProperties(newProperties)\n  const prevProperties = pick(node, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_node',\n    path,\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.setTextByPath = (editor, path, text, marks) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  editor.replaceTextByPath(path, 0, end, text, marks)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nCommands.splitNodeByPath = (editor, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = editor\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  editor.applyOperation({\n    type: 'split_node',\n    path,\n    position,\n    target,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n  })\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\nCommands.splitDescendantsByPath = (editor, path, textPath, textOffset) => {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  let index = textOffset\n  let lastPath = textPath\n\n  editor.withoutNormalizing(() => {\n    editor.splitNodeByKey(textPath, textOffset)\n\n    for (const [, ancestorPath] of document.ancestors(textPath)) {\n      const target = index\n      index = lastPath.last() + 1\n      lastPath = ancestorPath\n      editor.splitNodeByPath(ancestorPath, index, { target })\n\n      if (ancestorPath.equals(path)) {\n        break\n      }\n    }\n  })\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapInlineByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapInlineAtRange(range, properties)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapBlockByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapBlockAtRange(range, properties)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  editor.withoutNormalizing(() => {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n      editor.removeNodeByPath(parentPath)\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex)\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n    } else {\n      let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n      editor.splitNodeByPath(parentPath, index)\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1)\n    }\n  })\n}\n\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapChildrenByPath = (editor, path) => {\n  path = PathUtils.create(path)\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const { nodes } = node\n\n  editor.withoutNormalizing(() => {\n    nodes.reverse().forEach((child, i) => {\n      const childIndex = nodes.size - i - 1\n      const childPath = path.push(childIndex)\n      editor.moveNodeByPath(childPath, parentPath, index + 1)\n    })\n\n    editor.removeNodeByPath(path)\n  })\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockByPath = (editor, path, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, block)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\nCommands.wrapInlineByPath = (editor, path, inline) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, inline)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\nCommands.wrapNodeByPath = (editor, path, node) => {\n  node = Node.create(node)\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node)\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node)\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst COMMANDS = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeAllMarks',\n  'removeMark',\n  'removeNode',\n  'removeText',\n  'replaceMarks',\n  'replaceNode',\n  'replaceText',\n  'setMark',\n  'setNode',\n  'setText',\n  'splitNode',\n  'unwrapBlock',\n  'unwrapChildren',\n  'unwrapInline',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of COMMANDS) {\n  Commands[`${method}ByKey`] = (editor, key, ...args) => {\n    const { value } = editor\n    const { document } = value\n    const path = document.assertPath(key)\n    editor[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nCommands.moveNodeByKey = (editor, key, newKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  editor.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nCommands.splitDescendantsByKey = (editor, key, textKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  editor.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import omit from 'lodash/omit'\nimport { List } from 'immutable'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands.save = (editor, operation) => {\n  // Disabled for performance (saves ~1-5ms), since we don't use slate's undo code at all right now\n  if (Date.now() > 0) return\n  const { operations, value } = editor\n  const { data } = value\n  let { save, merge } = editor.tmp\n  if (save === false || !isValidOperation(operation)) return\n\n  let undos = data.get('undos') || List()\n  const lastBatch = undos.last()\n  const lastOperation = lastBatch && lastBatch.last()\n\n  // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true\n    } else {\n      merge = shouldMerge(operation, lastOperation)\n    }\n  }\n\n  // If the `merge` flag is true, add the operation to the last batch.\n  if (merge && lastBatch) {\n    const batch = lastBatch.push(operation)\n    undos = undos.pop()\n    undos = undos.push(batch)\n  } else {\n    // Otherwise, create a new batch with the operation.\n    const batch = List([operation])\n    undos = undos.push(batch)\n  }\n\n  // Constrain the history to 100 entries for memory's sake.\n  if (undos.size > 100) {\n    undos = undos.takeLast(100)\n  }\n\n  // Clear the redos and update the history.\n  editor.withoutSaving(() => {\n    const redos = List()\n    const newData = data.set('undos', undos).set('redos', redos)\n    editor.setData(newData)\n  })\n}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.redo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = redos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the batch of operations.\n      batch.forEach(op => {\n        const { type, newProperties } = op\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n        if (type === 'set_selection') {\n          op = op.set('newProperties', omit(newProperties, 'isFocused'))\n        }\n\n        editor.applyOperation(op)\n      })\n\n      // Shift the next value into the undo stack.\n      redos = redos.pop()\n      undos = undos.push(batch)\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.undo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = undos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the inverse of the previous operations.\n      batch\n        .slice()\n        .reverse()\n        .map(op => op.invert())\n        .forEach(inverse => {\n          const { type, newProperties } = inverse\n\n          // When the operation mutates the selection, omit its `isFocused` value to\n          // prevent the editor focus from changing during undoing.\n          if (type === 'set_selection') {\n            inverse = inverse.set(\n              'newProperties',\n              omit(newProperties, 'isFocused')\n            )\n          }\n\n          editor.applyOperation(inverse)\n        })\n\n      // Shift the previous operations into the redo stack.\n      redos = redos.push(batch)\n      undos = undos.pop()\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutMerging = (editor, fn) => {\n  const value = editor.tmp.merge\n  editor.tmp.merge = false\n  fn(editor)\n  editor.tmp.merge = value\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutSaving = (editor, fn) => {\n  const value = editor.tmp.save\n  editor.tmp.save = false\n  fn(editor)\n  editor.tmp.save = value\n}\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type === 'set_selection' && p.type === 'set_selection') ||\n    (o.type === 'insert_text' &&\n      p.type === 'insert_text' &&\n      o.offset === p.offset + p.text.length &&\n      o.path.equals(p.path)) ||\n    (o.type === 'remove_text' &&\n      p.type === 'remove_text' &&\n      o.offset + o.text.length === p.offset &&\n      o.path.equals(p.path))\n\n  return merge\n}\n\n/**\n * Check weather an operation needs to be saved to the history\n * @param {Object} o - operation\n * @returns {Boolean}\n */\n\nfunction isValidOperation(o) {\n  if (o.type === 'set_selection') {\n    const { isFocused, anchor, focus } = o.newProperties\n\n    // this is blur/focus operation, dont need to store it into the history\n    if (isFocused !== undefined && !anchor && !focus) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import { is } from 'immutable'\nimport pick from 'lodash/pick'\n\nimport Selection from '../models/selection'\nimport TextUtils from '../utils/text-utils'\n\nconst Commands = {}\n\nCommands.blur = editor => {\n  editor.select({ isFocused: false })\n}\n\nCommands.deselect = editor => {\n  const range = Selection.create()\n  editor.select(range)\n}\n\nCommands.focus = editor => {\n  editor.select({ isFocused: true })\n}\n\nCommands.flip = editor => {\n  editor.command(proxy, 'flip')\n}\n\nCommands.moveAnchorBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorForward = (editor, ...args) => {\n  editor.command(pointForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorTo = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorTo', ...args)\n}\n\nCommands.moveAnchorToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block')\n}\n\nCommands.moveAnchorToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline')\n}\n\nCommands.moveAnchorToEndOfDocument = editor => {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block')\n}\n\nCommands.moveAnchorToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline')\n}\n\nCommands.moveAnchorToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text')\n}\n\nCommands.moveAnchorToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToEndOfNode', ...args)\n}\n\nCommands.moveAnchorToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block')\n}\n\nCommands.moveAnchorToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline')\n}\n\nCommands.moveAnchorToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text')\n}\n\nCommands.moveAnchorToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text')\n}\n\nCommands.moveAnchorToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block')\n}\n\nCommands.moveAnchorToStartOfDocument = editor => {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block')\n}\n\nCommands.moveAnchorToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text')\n}\n\nCommands.moveAnchorToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToStartOfNode', ...args)\n}\n\nCommands.moveAnchorToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block')\n}\n\nCommands.moveAnchorToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline')\n}\n\nCommands.moveAnchorToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text')\n}\n\nCommands.moveAnchorToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text')\n}\n\nCommands.moveBackward = (editor, chars = 1) => {\n  if (chars === 0) return\n\n  const { value } = editor\n  const { document, selection } = value\n  const { start } = selection\n  const startBlock = document.getClosestBlock(start.key)\n  const o = startBlock.getOffset(start.key)\n  const offset = o + start.offset\n  const { text } = startBlock\n  const charsOffset = TextUtils.getCharOffsetBackward(text, offset, chars)\n  editor.moveAnchorBackward(charsOffset).moveFocusBackward(charsOffset)\n}\n\nCommands.moveWordBackward = (editor, ...args) => {\n  editor.moveFocusWordBackward(...args).moveToFocus()\n}\n\nCommands.moveEndBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'end', ...args)\n}\n\nCommands.moveEndWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'end', ...args)\n}\n\nCommands.moveEndForward = (editor, ...args) => {\n  editor.command(pointForward, 'end', ...args)\n}\n\nCommands.moveEndWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'end', ...args)\n}\n\nCommands.moveEndTo = (editor, ...args) => {\n  editor.command(proxy, 'moveEndTo', ...args)\n}\n\nCommands.moveEndToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'block')\n}\n\nCommands.moveEndToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline')\n}\n\nCommands.moveEndToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block')\n}\n\nCommands.moveEndToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline')\n}\n\nCommands.moveEndToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text')\n}\n\nCommands.moveEndToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToEndOfNode', ...args)\n}\n\nCommands.moveEndToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block')\n}\n\nCommands.moveEndToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline')\n}\n\nCommands.moveEndToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text')\n}\n\nCommands.moveEndToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'text')\n}\n\nCommands.moveEndToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'block')\n}\n\nCommands.moveEndToStartOfDocument = editor => {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline')\n}\n\nCommands.moveEndToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block')\n}\n\nCommands.moveEndToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline')\n}\n\nCommands.moveEndToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text')\n}\n\nCommands.moveEndToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToStartOfNode', ...args)\n}\n\nCommands.moveEndToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block')\n}\n\nCommands.moveEndToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline')\n}\n\nCommands.moveEndToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text')\n}\n\nCommands.moveEndToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'text')\n}\n\nCommands.moveFocusBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'focus', ...args)\n}\n\nCommands.moveFocusWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'focus', ...args)\n}\n\nCommands.moveFocusForward = (editor, ...args) => {\n  editor.command(pointForward, 'focus', ...args)\n}\n\nCommands.moveFocusWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'focus', ...args)\n}\n\nCommands.moveFocusTo = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusTo', ...args)\n}\n\nCommands.moveFocusToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block')\n}\n\nCommands.moveFocusToEndOfDocument = editor => {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline')\n}\n\nCommands.moveFocusToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block')\n}\n\nCommands.moveFocusToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline')\n}\n\nCommands.moveFocusToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text')\n}\n\nCommands.moveFocusToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToEndOfNode', ...args)\n}\n\nCommands.moveFocusToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block')\n}\n\nCommands.moveFocusToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline')\n}\n\nCommands.moveFocusToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text')\n}\n\nCommands.moveFocusToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text')\n}\n\nCommands.moveFocusToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block')\n}\n\nCommands.moveFocusToStartOfDocument = editor => {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline')\n}\n\nCommands.moveFocusToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block')\n}\n\nCommands.moveFocusToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline')\n}\n\nCommands.moveFocusToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text')\n}\n\nCommands.moveFocusToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToStartOfNode', ...args)\n}\n\nCommands.moveFocusToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block')\n}\n\nCommands.moveFocusToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline')\n}\n\nCommands.moveFocusToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text')\n}\n\nCommands.moveFocusToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text')\n}\n\nCommands.moveForward = (editor, chars = 1) => {\n  if (chars === 0) return\n\n  const { value } = editor\n  const { document, selection } = value\n  const { start } = selection\n  const startBlock = document.getClosestBlock(start.path)\n  const o = startBlock.getOffset(start.key)\n  const offset = o + start.offset\n  const { text } = startBlock\n  const charsOffset = TextUtils.getCharOffsetForward(text, offset, chars)\n  editor.moveAnchorForward(charsOffset).moveFocusForward(charsOffset)\n}\n\nCommands.moveWordForward = (editor, ...args) => {\n  editor.moveFocusWordForward(...args).moveToFocus(...args)\n}\n\nCommands.moveStartBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'start', ...args)\n}\n\nCommands.moveStartWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'start', ...args)\n}\n\nCommands.moveStartForward = (editor, ...args) => {\n  editor.command(pointForward, 'start', ...args)\n}\n\nCommands.moveStartWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'start', ...args)\n}\n\nCommands.moveStartTo = (editor, ...args) => {\n  editor.command(proxy, 'moveStartTo', ...args)\n}\n\nCommands.moveStartToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'block')\n}\n\nCommands.moveStartToEndOfDocument = editor => {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline')\n}\n\nCommands.moveStartToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block')\n}\n\nCommands.moveStartToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline')\n}\n\nCommands.moveStartToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text')\n}\n\nCommands.moveStartToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToEndOfNode', ...args)\n}\n\nCommands.moveStartToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block')\n}\n\nCommands.moveStartToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline')\n}\n\nCommands.moveStartToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text')\n}\n\nCommands.moveStartToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'text')\n}\n\nCommands.moveStartToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'block')\n}\n\nCommands.moveStartToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline')\n}\n\nCommands.moveStartToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block')\n}\n\nCommands.moveStartToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline')\n}\n\nCommands.moveStartToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text')\n}\n\nCommands.moveStartToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToStartOfNode', ...args)\n}\n\nCommands.moveStartToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block')\n}\n\nCommands.moveStartToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline')\n}\n\nCommands.moveStartToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text')\n}\n\nCommands.moveStartToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'text')\n}\n\nCommands.moveTo = (editor, ...args) => {\n  editor.command(proxy, 'moveTo', ...args)\n}\n\nCommands.moveToAnchor = editor => {\n  editor.command(proxy, 'moveToAnchor')\n}\n\nCommands.moveToEnd = editor => {\n  editor.command(proxy, 'moveToEnd')\n}\n\nCommands.moveToEndOfBlock = editor => {\n  editor.moveEndToEndOfBlock().moveToEnd()\n}\n\nCommands.moveToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveToEndOfInline = editor => {\n  editor.moveEndToEndOfInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextBlock = editor => {\n  editor.moveEndToEndOfNextBlock().moveToEnd()\n}\n\nCommands.moveToEndOfNextInline = editor => {\n  editor.moveEndToEndOfNextInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextText = editor => {\n  editor.moveEndToEndOfNextText().moveToEnd()\n}\n\nCommands.moveToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToEndOfNode', ...args)\n}\n\nCommands.moveToEndOfPreviousBlock = editor => {\n  editor.moveStartToEndOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToEndOfPreviousInline = editor => {\n  editor.moveStartToEndOfPreviousInline().moveToStart()\n}\n\nCommands.moveToEndOfPreviousText = editor => {\n  editor.moveStartToEndOfPreviousText().moveToStart()\n}\n\nCommands.moveToEndOfText = editor => {\n  editor.moveEndToEndOfText().moveToEnd()\n}\n\nCommands.moveToFocus = editor => {\n  editor.command(proxy, 'moveToFocus')\n}\n\nCommands.moveToRangeOfDocument = editor => {\n  editor.moveToRangeOfNode(editor.value.document)\n}\n\nCommands.moveToRangeOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToRangeOfNode', ...args)\n}\n\nCommands.moveToStart = editor => {\n  editor.command(proxy, 'moveToStart')\n}\n\nCommands.moveToStartOfBlock = editor => {\n  editor.moveStartToStartOfBlock().moveToStart()\n}\n\nCommands.moveToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveToStartOfInline = editor => {\n  editor.moveStartToStartOfInline().moveToStart()\n}\n\nCommands.moveToStartOfNextBlock = editor => {\n  editor.moveEndToStartOfNextBlock().moveToEnd()\n}\n\nCommands.moveToStartOfNextInline = editor => {\n  editor.moveEndToStartOfNextInline().moveToEnd()\n}\n\nCommands.moveToStartOfNextText = editor => {\n  editor.moveEndToStartOfNextText().moveToEnd()\n}\n\nCommands.moveToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToStartOfNode', ...args)\n}\n\nCommands.moveToStartOfPreviousBlock = editor => {\n  editor.moveStartToStartOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToStartOfPreviousInline = editor => {\n  editor.moveStartToStartOfPreviousInline().moveToStart()\n}\n\nCommands.moveToStartOfPreviousText = editor => {\n  editor.moveStartToStartOfPreviousText().moveToStart()\n}\n\nCommands.moveToStartOfText = editor => {\n  editor.moveStartToStartOfText().moveToStart()\n}\n\nCommands.select = (editor, properties, options = {}) => {\n  properties = Selection.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = editor\n  const { document, selection } = value\n  const newProperties = {}\n  let next = selection.setProperties(properties)\n  next = document.resolveSelection(next)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      newProperties[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (\n    selection.marks &&\n    !newProperties.marks &&\n    (newProperties.anchor || newProperties.focus)\n  ) {\n    newProperties.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(newProperties).length === 0) {\n    return\n  }\n\n  // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n  const prevProperties = pick(selection.toJSON(), Object.keys(newProperties))\n\n  editor.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: prevProperties,\n      newProperties,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\nCommands.setAnchor = (editor, ...args) => {\n  editor.command(proxy, 'setAnchor', ...args)\n}\n\nCommands.setEnd = (editor, ...args) => {\n  editor.command(proxy, 'setEnd', ...args)\n}\n\nCommands.setFocus = (editor, ...args) => {\n  editor.command(proxy, 'setFocus', ...args)\n}\n\nCommands.setStart = (editor, ...args) => {\n  editor.command(proxy, 'setStart', ...args)\n}\n\nCommands.snapshotSelection = editor => {\n  editor.withoutMerging(() => {\n    editor.select(editor.value.selection, { snapshot: true })\n  })\n}\n\n/**\n * Helpers.\n */\n\nfunction proxy(editor, method, ...args) {\n  const range = editor.value.selection[method](...args)\n  editor.select(range)\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  editor[method](node)\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Side = side.slice(0, 1).toUpperCase() + side.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const getDirectionNode = `get${Side}${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  const target = document[getDirectionNode](node.key)\n  if (!target) return\n  editor[method](target)\n}\n\nfunction pointBackward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointForward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    const range = selection[`move${Point}Backward`](n)\n    editor.select(range)\n    return\n  }\n\n  const previous = document.getPreviousText(p.path)\n  if (!previous) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(previous.key)\n  const isPreviousInVoid =\n    previous && document.hasVoidParent(previous.key, editor)\n  editor[`move${Point}ToEndOfNode`](previous)\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Backward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointForward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointBackward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const text = document.getNode(p.path)\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    const range = selection[`move${Point}Forward`](n)\n    editor.select(range)\n    return\n  }\n\n  const next = document.getNextText(p.path)\n  if (!next) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(next.key)\n  const isNextInVoid = document.hasVoidParent(next.key, editor)\n  editor[`move${Point}ToStartOfNode`](next)\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Forward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetBackward(text, o)\n  editor.command(pointBackward, pointName, n > 0 ? n : 1)\n}\n\nfunction pointWordForward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetForward(text, o)\n  editor.command(pointForward, pointName, n > 0 ? n : 1)\n}\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Annotation from '../models/annotation'\nimport Value from '../models/value'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands.setData = (editor, data = {}) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ data })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\nCommands.addAnnotation = (editor, annotation) => {\n  annotation = Annotation.create(annotation)\n\n  editor.applyOperation({\n    type: 'add_annotation',\n    annotation,\n  })\n}\n\nCommands.removeAnnotation = (editor, annotation) => {\n  annotation = Annotation.create(annotation)\n\n  editor.applyOperation({\n    type: 'remove_annotation',\n    annotation,\n  })\n}\n\nCommands.setAnnotation = (editor, annotation, newProperties) => {\n  annotation = Annotation.create(annotation)\n  newProperties = Annotation.createProperties(newProperties)\n\n  editor.applyOperation({\n    type: 'set_annotation',\n    properties: annotation,\n    newProperties,\n  })\n}\n\nCommands.setAnnotations = (editor, annotations = []) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ annotations })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\nfunction QueriesPlugin(queries = {}) {\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const query in queries) {\n      editor.registerQuery(query)\n    }\n\n    return next()\n  }\n\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onQuery(query, editor, next) {\n    const { type, args } = query\n    const fn = queries[type]\n    if (!fn) return next()\n    const ret = fn(editor, ...args)\n    return ret === undefined ? next() : ret\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onConstruct,\n    onQuery,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default QueriesPlugin\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import SlateError from '../utils/slate-error'\nimport Queries from './queries'\n\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\nfunction SchemaPlugin(schema) {\n  const {\n    rules,\n    document,\n    blocks,\n    inlines,\n    marks,\n    annotations,\n    decorations,\n  } = schema\n  let schemaRules = []\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules)\n  }\n\n  if (document) {\n    schemaRules.push({\n      match: [{ object: 'document' }],\n      ...document,\n    })\n  }\n\n  if (blocks) {\n    for (const key in blocks) {\n      schemaRules.push({\n        match: [{ object: 'block', type: key }],\n        ...blocks[key],\n      })\n    }\n  }\n\n  if (inlines) {\n    for (const key in inlines) {\n      schemaRules.push({\n        match: [{ object: 'inline', type: key }],\n        ...inlines[key],\n      })\n    }\n  }\n\n  if (marks) {\n    for (const key in marks) {\n      schemaRules.push({\n        match: [{ object: 'mark', type: key }],\n        ...marks[key],\n      })\n    }\n  }\n\n  if (annotations) {\n    for (const key in annotations) {\n      schemaRules.push({\n        match: [{ object: 'annotation', type: key }],\n        ...annotations[key],\n      })\n    }\n  }\n\n  if (decorations) {\n    for (const key in decorations) {\n      schemaRules.push({\n        match: [{ object: 'decoration', type: key }],\n        ...decorations[key],\n      })\n    }\n  }\n\n  /**\n   * Check if a `format` is atomic based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Format} format\n   * @return {Boolean}\n   */\n\n  function isAtomic(editor, format) {\n    const rule = schemaRules.find(\n      r => 'isAtomic' in r && testRules(format, r.match)\n    )\n\n    return rule && rule.isAtomic\n  }\n\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isVoid(editor, node) {\n    const rule = schemaRules.find(\n      r => 'isVoid' in r && testRules(node, r.match)\n    )\n\n    return rule && rule.isVoid\n  }\n\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n  function normalizeNode(node, editor, next) {\n    const error = validateNode(node, editor, () => {})\n    if (!error) return next()\n\n    return () => {\n      const { rule } = error\n      const { size } = editor.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(editor, error)\n      }\n\n      // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error)\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n  function validateNode(node, editor, next) {\n    const matches = schemaRules.filter(r => testRules(node, r.match))\n    const failure = validateRules(node, matches, schemaRules, { every: true })\n    if (!failure) return next()\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n  const queries = Queries({ isAtomic, isVoid })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{ normalizeNode, validateNode }, queries]\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(editor, error) {\n  const { code, node, child, next, previous, key, mark } = error\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid': {\n      return child.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(child.key)\n    }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid': {\n      return previous.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(previous.key)\n    }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid': {\n      return next.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(next.key)\n    }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid': {\n      return node.object === 'document'\n        ? node.nodes.forEach(n => editor.removeNodeByKey(n.key))\n        : editor.removeNodeByKey(node.key)\n    }\n\n    case 'node_data_invalid': {\n      return node.data.get(key) === undefined && node.object !== 'document'\n        ? editor.removeNodeByKey(node.key)\n        : editor.setNodeByKey(node.key, { data: node.data.delete(key) })\n    }\n\n    case 'node_mark_invalid': {\n      return node\n        .getTexts()\n        .forEach(t => editor.removeMarkByKey(t.key, 0, t.text.length, mark))\n    }\n\n    default: {\n      return editor.removeNodeByKey(node.key)\n    }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  const error = validateRules(object, rules)\n  return !error\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules, options = {}) {\n  const { every = false, match = null } = options\n\n  if (typeof rule === 'function') {\n    const valid = rule(object, match)\n    return valid ? null : fail('node_invalid', { rule, node: object })\n  }\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(object, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(object, rule) ||\n    validateType(object, rule) ||\n    validateData(object, rule) ||\n    validateMarks(object, rule) ||\n    validateText(object, rule) ||\n    validateFirst(object, rule) ||\n    validateLast(object, rule) ||\n    validateNodes(object, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  if (typeof rule.object === 'function' && rule.object(node.object)) return\n  return fail('node_object_invalid', { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  if (typeof rule.type === 'function' && rule.type(node.type)) return\n  return fail('node_type_invalid', { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return\n    return fail('node_data_invalid', { rule, node })\n  }\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail('node_data_invalid', { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n\n  const marks =\n    node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(\n      def =>\n        typeof def.type === 'function'\n          ? def.type(mark.type)\n          : def.type === mark.type\n    )\n    if (valid) continue\n    return fail('node_mark_invalid', { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid =\n    typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text)\n  if (valid) return\n  return fail('node_text_invalid', { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let count = 0\n  let lastCount = 0\n  let min = null\n  let index = -1\n  let def = null\n  let max = null\n  let child = null\n  let previous = null\n  let next = null\n\n  function nextDef() {\n    if (defs.length === 0) return false\n    def = defs.shift()\n    lastCount = count\n    count = 0\n    min = def.min || null\n    max = def.max || null\n    return true\n  }\n\n  function nextChild() {\n    index += 1\n    previous = index ? children.get(index - 1) : null\n    child = children.get(index)\n    next = children.get(index + 1)\n    if (!child) return false\n    lastCount = count\n    count += 1\n    return true\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1\n      count = lastCount\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule, node, child, index })\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind()\n            return fail('child_max_invalid', {\n              rule,\n              node,\n              index,\n              child: children.get(index),\n              count,\n              limit: max,\n            })\n          }\n\n          const lastMin = min\n\n          // If there are more groups after this one then child might actually\n          // be valid.\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1\n              continue\n            }\n\n            // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n            if (validateRules(child, def.match) == null) {\n              rewind()\n              return fail('child_min_invalid', {\n                rule,\n                node,\n                index,\n                count: lastCount - 1,\n                limit: lastMin,\n              })\n            }\n\n            // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n            error.rule = rule\n            error.node = node\n            error.child = child\n            error.index = index\n            error.code = error.code.replace('node_', 'child_')\n            return error\n          }\n\n          // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n          if (max != null && count > max) {\n            return fail('child_unknown', { rule, node, child, index })\n          }\n\n          // ... or it's an invalid child for the last group.\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule,\n      node,\n      index: index - 1,\n      count,\n      child: children.get(index - 1),\n      limit: max,\n    })\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule,\n          node,\n          index,\n          count,\n          limit: min,\n        })\n      }\n    } while (nextDef())\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next, [], { match: child })\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default SchemaPlugin\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\nfunction deleteExpanded(editor) {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  }\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.addMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\nCommands.addMarks = (editor, marks) => {\n  marks.forEach(mark => editor.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\nCommands.delete = editor => {\n  const { value } = editor\n  const { selection } = value\n  editor.deleteAtRange(selection)\n\n  // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n  editor.moveToFocus()\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteBackwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteForward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteForwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordForwardAtRange(selection)\n  }\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\nCommands.insertBlock = (editor, block) => {\n  deleteExpanded(editor)\n\n  block = Block.create(block)\n  const { value } = editor\n  const { selection } = value\n  editor.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(block.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\nCommands.insertFragment = (editor, fragment) => {\n  if (!fragment.nodes.size) return\n\n  deleteExpanded(editor)\n\n  let { value } = editor\n  let { document, selection } = value\n  const { start } = selection\n  const keys = Array.from(document.texts(), ([text]) => text.key)\n\n  editor.insertFragmentAtRange(selection, fragment)\n  value = editor.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  if (newTexts.size === 0) return\n  const fragmentLength = fragment.text.length\n\n  // Either startText is still here, or we want the first un-previously known text\n  const startText = document.getNode(start.key) || newTexts.first()\n  // We want the last un-previously known text\n  const endText = newTexts.last() || startText\n\n  if (startText === endText) {\n    editor.moveTo(endText.key, fragmentLength)\n    return\n  }\n\n  // This code causes the selection on paste to miss newlines at the end of the paste\n  // Just disabling it seems to fix the problem though?\n  // // Everything will be calculated relative to the first common ancestor to optimize speed\n  // const parent = document.getCommonAncestor(startText.key, endText.key)\n\n  // const startOffset =\n  //   parent.getOffset(startText.key) +\n  //   (start.key === startText.key ? start.offset : 0)\n\n  // // endText might not be the last un-previously known text node, so we precisely pick it by offset\n  // endText = parent.getTextAtOffset(startOffset + fragmentLength - 1) || endText\n\n  // editor.moveTo(\n  //   endText.key,\n  //   startOffset + fragmentLength - parent.getOffset(endText.key)\n  // )\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\nCommands.insertInline = (editor, inline) => {\n  deleteExpanded(editor)\n\n  inline = Inline.create(inline)\n  const { value } = editor\n  const { selection } = value\n  editor.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(inline.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertText = (editor, text, marks) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(selection, text, marks)\n\n    // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({ marks: null })\n    }\n  })\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.removeMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nCommands.replaceMark = (editor, oldMark, newMark) => {\n  editor.removeMark(oldMark)\n  editor.addMark(newMark)\n}\n\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setBlocks = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setBlocksAtRange(selection, properties)\n}\n\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setInlines = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setInlinesAtRange(selection, properties)\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\nCommands.splitBlock = (editor, depth = 1) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  editor.splitBlockAtRange(selection, depth).moveToEnd()\n\n  if (marks && marks.size !== 0) {\n    editor.select({ marks })\n  }\n}\n\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\nCommands.splitInline = (editor, height) => {\n  deleteExpanded(editor)\n  const { value } = editor\n  const { selection } = value\n  editor.splitInlineAtRange(selection, height)\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.toggleMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    editor.removeMark(mark)\n  } else {\n    editor.addMark(mark)\n  }\n}\n\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlock = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapBlockAtRange(selection, properties)\n}\n\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapInline = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapInlineAtRange(selection, properties)\n}\n\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlock = (editor, block) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapBlockAtRange(selection, block)\n}\n\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInline = (editor, inline) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapInlineAtRange(selection, inline)\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\nCommands.wrapText = (editor, prefix, suffix = prefix) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  editor.moveEndBackward(suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import AtRange from '../commands/at-range'\nimport ByPath from '../commands/by-path'\nimport Commands from './commands'\nimport OnHistory from '../commands/on-history'\nimport OnSelection from '../commands/on-selection'\nimport OnValue from '../commands/on-value'\nimport Queries from './queries'\nimport Schema from './schema'\nimport Text from '../models/text'\nimport WithIntent from '../commands/with-intent'\n\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction CorePlugin(options = {}) {\n  const { plugins = [] } = options\n\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  const commands = Commands({\n    ...AtRange,\n    ...ByPath,\n    ...OnHistory,\n    ...OnSelection,\n    ...OnValue,\n    ...WithIntent,\n  })\n\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  const queries = Queries({\n    isAtomic: () => false,\n    isVoid: () => false,\n  })\n\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  const schema = Schema({\n    rules: [\n      // Only allow block nodes in documents.\n      {\n        match: { object: 'document' },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n\n      // Only allow block nodes or inline and text nodes in blocks.\n      {\n        match: {\n          object: 'block',\n          first: { object: 'block' },\n        },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n      {\n        match: {\n          object: 'block',\n          first: [{ object: 'inline' }, { object: 'text' }],\n        },\n        nodes: [\n          {\n            match: [{ object: 'inline' }, { object: 'text' }],\n          },\n        ],\n      },\n\n      // Only allow inline and text nodes in inlines.\n      {\n        match: { object: 'inline' },\n        nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n      },\n\n      // Ensure that block and inline nodes have at least one text child.\n      {\n        match: [{ object: 'block' }, { object: 'inline' }],\n        nodes: [{ min: 1 }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n\n          if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n            editor.insertNodeByKey(node.key, 0, Text.create())\n          }\n        },\n      },\n\n      // Ensure that inline nodes are surrounded by text nodes.\n      {\n        match: { object: 'block' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n      {\n        match: { object: 'inline' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        previous: [{ object: 'block' }, { object: 'text' }],\n        next: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node, index } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else if (code === 'previous_sibling_object_invalid') {\n            i = index\n          } else if (code === 'next_sibling_object_invalid') {\n            i = index + 1\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n\n      // Merge adjacent text nodes with the same marks.\n      {\n        match: { object: 'text' },\n        next: (next, match) => {\n          return next.object !== 'text' || !match.marks.equals(next.marks)\n        },\n        normalize: (editor, error) => {\n          const { code, next } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.mergeNodeByKey(next.key)\n          }\n        },\n      },\n\n      // Remove extra adjacent empty text nodes.\n      {\n        match: { object: 'text' },\n        previous: prev => {\n          return prev.object !== 'text' || prev.text !== ''\n        },\n        next: next => {\n          return next.object !== 'text' || next.text !== ''\n        },\n        normalize: (editor, error) => {\n          const { code, next, previous } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.removeNodeByKey(next.key)\n          } else if (code === 'previous_sibling_invalid') {\n            editor.removeNodeByKey(previous.key)\n          }\n        },\n      },\n    ],\n  })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema, ...plugins, commands, queries]\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CorePlugin\n","import Debug from 'debug'\nimport invariant from 'tiny-invariant'\nimport isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport CommandsPlugin from '../plugins/commands'\nimport CorePlugin from '../plugins/core'\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\nimport QueriesPlugin from '../plugins/queries'\nimport SchemaPlugin from '../plugins/schema'\nimport Value from '../models/value'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nclass Editor {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n\n  constructor(attrs = {}, options = {}) {\n    const { controller = this, construct = true } = options\n    const {\n      onChange = () => {},\n      plugins = [],\n      readOnly = false,\n      value = Value.create(),\n    } = attrs\n\n    this.controller = controller\n    this.middleware = {}\n    this.onChange = onChange\n    this.operations = List()\n    this.readOnly = null\n    this.value = null\n\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true,\n    }\n\n    const core = CorePlugin({ plugins })\n    registerPlugin(this, core)\n\n    if (construct) {\n      this.run('onConstruct')\n      this.setReadOnly(readOnly)\n      this.setValue(value, options)\n    }\n  }\n\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n  applyOperation(operation) {\n    const { operations, controller } = this\n    let value = this.value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Save the operation into the history. Since `save` is a command, we need\n    // to do it without normalizing, since it would have side effects.\n    this.withoutNormalizing(() => {\n      controller.save(operation)\n      value = this.value\n    })\n\n    // Apply the operation to the value.\n    debug('apply', { operation })\n    this.value = operation.apply(value)\n    this.operations = operations.push(operation)\n\n    // Get the paths of the affected nodes, and mark them as dirty.\n    const newDirtyPaths = getDirtyPaths(operation)\n\n    const dirty = this.tmp.dirty.map(path => {\n      path = PathUtils.create(path)\n      const transformed = PathUtils.transform(path, operation)\n      return transformed.toArray()\n    })\n\n    const pathIndex = {}\n    const dirtyPaths = Array.prototype.concat.apply(newDirtyPaths, dirty)\n    this.tmp.dirty = []\n\n    // PERF: De-dupe the paths so we don't do extra normalization.\n    dirtyPaths.forEach(dirtyPath => {\n      const key = dirtyPath.join(',')\n\n      if (!pathIndex[key]) {\n        this.tmp.dirty.push(dirtyPath)\n      }\n\n      pathIndex[key] = true\n    })\n\n    // If we're not already, queue the flushing process on the next tick.\n    if (!this.tmp.flushing) {\n      this.tmp.flushing = true\n      Promise.resolve().then(() => this.flush())\n    }\n\n    return controller\n  }\n\n  fastInsertText(path, offset, text, marks) {\n    this.value = this.value.insertText(path, offset, text, marks)\n\n    // If we're not already, queue the flushing process on the next tick.\n    if (!this.tmp.flushing) {\n      this.tmp.flushing = true\n      Promise.resolve().then(() => this.flush())\n    }\n\n    return this.controller\n  }\n\n  /**\n   * Flush the editor's current change.\n   *\n   * @return {Editor}\n   */\n\n  flush() {\n    this.run('onChange')\n    const { value, operations, controller } = this\n    const change = { value, operations }\n    this.operations = List()\n    this.tmp.flushing = false\n    this.onChange(change)\n    return controller\n  }\n\n  /**\n   * Trigger a command by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Editor}\n   */\n\n  command(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      type(controller, ...args)\n      normalizeDirtyPaths(this)\n      return controller\n    }\n\n    debug('command', { type, args })\n    const obj = { type, args }\n    this.run('onCommand', obj)\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Checks if a command by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasCommand(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__command\n\n    return has\n  }\n\n  /**\n   * Checks if a query by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasQuery(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__query\n\n    return has\n  }\n\n  /**\n   * Normalize all of the nodes in the document from scratch.\n   *\n   * @return {Editor}\n   */\n\n  normalize() {\n    const { value, controller } = this\n    let { document } = value\n    const table = document.getKeysToPathsTable()\n    const paths = Object.values(table).map(PathUtils.create)\n    this.tmp.dirty = this.tmp.dirty.concat(paths)\n    normalizeDirtyPaths(this)\n\n    const { selection } = value\n    document = value.document\n\n    if (selection.isUnset && document.nodes.size) {\n      controller.moveToStartOfDocument()\n    }\n\n    return controller\n  }\n\n  /**\n   * Ask a query by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  query(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      return type(controller, ...args)\n    }\n\n    debug('query', { type, args })\n    const obj = { type, args }\n    return this.run('onQuery', obj)\n  }\n\n  /**\n   * Register a command `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerCommand(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__command) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` command because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.command(type, ...args)\n    controller[type] = method\n    method.__command = true\n    return controller\n  }\n\n  /**\n   * Register a query `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerQuery(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__query) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` query because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.query(type, ...args)\n    controller[type] = method\n    method.__query = true\n    return controller\n  }\n\n  /**\n   * Run through the middleware stack by `key` with `args`.\n   *\n   * @param {String} key\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  run(key, ...args) {\n    const { controller, middleware } = this\n    const fns = middleware[key] || []\n    let i = 0\n\n    function next(...overrides) {\n      const fn = fns[i++]\n      if (!fn) return\n\n      if (overrides.length) {\n        args = overrides\n      }\n\n      const ret = fn(...args, controller, next)\n      return ret\n    }\n\n    Object.defineProperty(next, 'change', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'onChange', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'props', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'schema', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'stack', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    return next()\n  }\n\n  /**\n   * Set the `readOnly` flag.\n   *\n   * @param {Boolean} readOnly\n   * @return {Editor}\n   */\n\n  setReadOnly(readOnly) {\n    this.readOnly = readOnly\n    return this\n  }\n\n  /**\n   * Set the editor's `value`.\n   *\n   * @param {Value} value\n   * @param {Options} options\n   * @return {Editor}\n   */\n\n  setValue(value, options = {}) {\n    const { normalize = value !== this.value } = options\n    this.value = value\n\n    if (normalize) {\n      this.normalize()\n    }\n\n    return this\n  }\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, deferring\n   * normalization until after the function has finished executing.\n   *\n   * @param {Function} fn\n   * @return {Editor}\n   */\n\n  withoutNormalizing(fn) {\n    const { controller } = this\n    const value = this.tmp.normalize\n    this.tmp.normalize = false\n    fn(controller)\n    this.tmp.normalize = value\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    warning(\n      false,\n      \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\"\n    )\n\n    return this.controller\n  }\n\n  change(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`'\n    )\n\n    fn(this.controller, ...args)\n  }\n\n  call(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.'\n    )\n\n    fn(this.controller, ...args)\n    return this.controller\n  }\n\n  applyOperations(operations) {\n    warning(\n      false,\n      'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.'\n    )\n\n    operations.forEach(op => this.applyOperation(op))\n    return this.controller\n  }\n\n  setOperationFlag(key, value) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.'\n    )\n\n    this.tmp[key] = value\n    return this\n  }\n\n  getFlag(key, options = {}) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.getFlag` method has been deprecated.'\n    )\n\n    return options[key] !== undefined ? options[key] : this.tmp[key]\n  }\n\n  unsetOperationFlag(key) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.'\n    )\n\n    delete this.tmp[key]\n    return this\n  }\n\n  withoutNormalization(fn) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.'\n    )\n\n    return this.withoutNormalizing(fn)\n  }\n}\n\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\nfunction getDirtyPaths(operation) {\n  const { type, node, path, newPath } = operation\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path]\n    }\n\n    case 'insert_node': {\n      const table = node.getKeysToPathsTable()\n      const paths = Object.values(table).map(p => path.concat(p))\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path, ...paths]\n    }\n\n    case 'split_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const nextPath = PathUtils.increment(path)\n      return [...ancestors, path, nextPath]\n    }\n\n    case 'merge_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const previousPath = PathUtils.decrement(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      if (PathUtils.isEqual(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors = PathUtils.getAncestors(path).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      const newAncestors = PathUtils.getAncestors(newPath).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    while (editor.tmp.dirty.length) {\n      const path = editor.tmp.dirty.pop()\n      normalizeNodeByPath(editor, path)\n    }\n  })\n}\n\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nfunction normalizeNodeByPath(editor, path) {\n  const { controller } = editor\n  let { value } = editor\n  let { document } = value\n  let node = document.assertNode(path)\n  let iterations = 0\n  const max = 100 + (node.object === 'text' ? 1 : node.nodes.size)\n\n  while (node) {\n    const fn = node.normalize(controller)\n\n    if (!fn) {\n      break\n    }\n\n    // Run the normalize `fn` to fix the node.\n    fn(controller)\n\n    // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n    value = editor.value\n    document = value.document\n    const { key } = node\n    let found = document.getDescendant(path)\n\n    if (found && found.key === key) {\n      node = found\n    } else {\n      found = document.getDescendant(key)\n\n      if (found) {\n        node = found\n        path = document.getPath(key)\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break\n      }\n    }\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n  }\n}\n\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array|Null} plugin\n */\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(p => registerPlugin(editor, p))\n    return\n  }\n\n  if (plugin == null) {\n    return\n  }\n\n  const { commands, queries, schema, ...rest } = plugin\n\n  if (commands) {\n    const commandsPlugin = CommandsPlugin(commands)\n    registerPlugin(editor, commandsPlugin)\n  }\n\n  if (queries) {\n    const queriesPlugin = QueriesPlugin(queries)\n    registerPlugin(editor, queriesPlugin)\n  }\n\n  if (schema) {\n    const schemaPlugin = SchemaPlugin(schema)\n    registerPlugin(editor, schemaPlugin)\n  }\n\n  for (const key in rest) {\n    const fn = rest[key]\n    const middleware = (editor.middleware[key] = editor.middleware[key] || [])\n    middleware.push(fn)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Editor}\n */\n\nexport default Editor\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List, Record, Set } from 'immutable'\n\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.')\n\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `mark` to the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  addMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.add(mark))\n  }\n\n  /**\n   * Add a `set` of marks to the leaf.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Insert a text `string` into the leaf at `offset`.\n   *\n   * @param {Number} offset\n   * @param {String} string\n   * @return {Leaf}\n   */\n\n  insertText(offset, string) {\n    const { text } = this\n    const next = text.slice(0, offset) + string + text.slice(offset)\n    return this.set('text', next)\n  }\n\n  /**\n   * Remove a `mark` from the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\nexport default function mixin(Interface, Classes) {\n  for (const Class of Classes) {\n    // Copy static properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface)) {\n      if (Class.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface, name)\n      Object.defineProperty(Class, name, desc)\n    }\n\n    // Copy instance properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface.prototype)) {\n      if (Class.prototype.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface.prototype, name)\n      Object.defineProperty(Class.prototype, name, desc)\n    }\n  }\n}\n","import Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Change from '../models/change'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Editor from '../controllers/editor'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\nimport isObject, { TYPES } from '../utils/is-object'\nimport mixin from '../utils/mixin'\n\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\nfunction create(type) {\n  const TYPE = TYPES[type]\n  const camel = `${type.charAt(0).toUpperCase()}${type.slice(1)}`\n  const is = `is${camel}`\n\n  class ObjectInterface {\n    /**\n     * Return the type of the object.\n     *\n     * @return {String}\n     */\n\n    get object() {\n      return type\n    }\n  }\n\n  ObjectInterface[is] = isObject.bind(null, type)\n  ObjectInterface.prototype[TYPE] = true\n  return ObjectInterface\n}\n\n/**\n * Mix in the object interfaces.\n */\n\nObject.entries({\n  Annotation,\n  Block,\n  Change,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n}).forEach(([camel, obj]) => mixin(create(camel.toLowerCase()), [obj]))\n","import mixin from '../utils/mixin'\nimport Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nclass ModelInterface {\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS(...args) {\n    return this.fromJSON(...args)\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(...args) {\n    return this.toJSON(...args)\n  }\n}\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(ModelInterface, [\n  Annotation,\n  Block,\n  Decoration,\n  Document,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n])\n","/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nconst LEAF = Symbol('LEAF')\n\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nconst STORE_KEY = Symbol('STORE_KEY')\n\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nconst UNDEFINED = Symbol('undefined')\nconst NULL = Symbol('null')\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nlet memoizeStore = new WeakMap()\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {},\n        })\n      }\n\n      const { noArgs, hasArgs } = memoizeStore.get(this)\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(hasArgs, keys)\n      } else {\n        cachedValue = noArgs[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v)\n      } else {\n        noArgs[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key === 'object') {\n      map = map[STORE_KEY] && map[STORE_KEY].get(key)\n    } else {\n      map = map[key]\n    }\n\n    if (map === UNSET) return UNSET\n  }\n\n  return map[LEAF]\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let child = map\n\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key !== 'object') {\n      if (!child[key]) {\n        child[key] = {}\n      }\n\n      child = child[key]\n      continue\n    }\n\n    if (!child[STORE_KEY]) {\n      child[STORE_KEY] = new WeakMap()\n    }\n\n    if (!child[STORE_KEY].has(key)) {\n      const newChild = {}\n      child[STORE_KEY].set(key, newChild)\n      child = newChild\n      continue\n    }\n\n    child = child[STORE_KEY].get(key)\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child[LEAF] = value\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap()\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Node from '../models/node'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Text from '../models/text'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass NodeInterface {\n  /**\n   * Get the first text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    if (this.nodes) {\n      this.nodes.forEach((node, i) => {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n\n          warning(\n            !(key in ret),\n            `A node with a duplicate key of \"${key}\" was found! Duplicate keys are not allowed, you should use \\`node.regenerateKey\\` before inserting if you are reusing an existing node.`\n          )\n\n          ret[key] = [i, ...path]\n        }\n      })\n    }\n\n    return ret\n  }\n\n  /**\n   * Get the last text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object === 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a node in the tree, or the node itself.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (this.object === 'text' && path.size) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // COMPAT: Handle passing in a path, to match other methods.\n    if (List.isList(key)) {\n      return key\n    }\n\n    // COMPAT: Handle a node object by iterating the descendants tree, so that\n    // we avoid using keys for the future.\n    if (Node.isNode(key) && this.descendants) {\n      for (const [node, path] of this.descendants()) {\n        if (key === node) return path\n      }\n    }\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the concatenated text string of a node.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    if (this.object === 'text') {\n      return this.text\n    }\n\n    const text = this.nodes.reduce((memo, c) => memo + c.text, '')\n    return text\n  }\n\n  /**\n   * Check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Normalize the text node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Function|Void}\n   */\n\n  normalize(editor) {\n    const normalizer = editor.run('normalizeNode', this)\n    return normalizer\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Validate the node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Error|Void}\n   */\n\n  validate(editor) {\n    const error = editor.run('validateNode', this)\n    return error\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, [\n  'getFirstText',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getText',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text])\n","export default typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {}\n","export default function identity() {\n  return true\n}\n","import getDirection from 'direction'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Value from '../models/value'\nimport identity from '../utils/identity'\nimport memoize from '../utils/memoize'\nimport mixin from '../utils/mixin'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass ElementInterface {\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.addMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all of the ancestors of the node.\n   *\n   * @return {Iterable}\n   */\n\n  ancestors(path) {\n    const iterable = this.createIterable({\n      path,\n      direction: null,\n      downward: false,\n      includeTargetAncestors: true,\n      includeRoot: true,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Create an iteratable for all of the blocks of a node with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  blocks(options = {}) {\n    const { onlyLeaves, onlyRoots, onlyTypes, match, ...rest } = options\n    const iterable = this.descendants({\n      includeDocument: false,\n      includeInlines: false,\n      includeTexts: false,\n      ...rest,\n      match: (node, path) => {\n        if (onlyTypes && !onlyTypes.includes(node.type)) {\n          return false\n        } else if (onlyRoots && path.size !== 1) {\n          return false\n        } else if (onlyLeaves && !node.isLeafBlock()) {\n          return false\n        } else if (match && !match(node, path)) {\n          return false\n        } else {\n          return true\n        }\n      },\n    })\n\n    return iterable\n  }\n\n  /**\n   * Create an annotation with `properties` relative to the node.\n   *\n   * @param {Object|Annotation} properties\n   * @return {Annotation}\n   */\n\n  createAnnotation(properties) {\n    properties = Annotation.createProperties(properties)\n    const annotation = this.resolveAnnotation(properties)\n    return annotation\n  }\n\n  /**\n   * Create a decoration with `properties` relative to the node.\n   *\n   * @param {Object|Decoration} properties\n   * @return {Decoration}\n   */\n\n  createDecoration(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.resolveDecoration(properties)\n    return decoration\n  }\n\n  /**\n   * Create an iteratable function starting at `target` path with `options`.\n   *\n   * @param {Object} options (optional)\n   * @return {Function}\n   */\n\n  createIterable(options = {}) {\n    const {\n      direction = 'forward',\n      downward = true,\n      upward = true,\n      includeBlocks = true,\n      includeDocument = true,\n      includeInlines = true,\n      includeRoot = false,\n      includeTarget = !!options.range,\n      includeTargetAncestors = false,\n      includeTexts = true,\n      match = null,\n    } = options\n\n    const root = this\n    let targetPath = null\n    let targetRange = null\n\n    // You can iterate over either a range or a path, but not both.\n    if (options.range) {\n      targetRange = root.resolveRange(options.range)\n      targetPath = root.resolvePath(targetRange.start.path)\n    } else if (options.path) {\n      targetPath = root.resolvePath(options.path)\n    }\n\n    const targetNode = targetPath && root.assertNode(targetPath)\n    const NativeSet = typeof window === 'undefined' ? global.Set : window.Set\n\n    // Return an object that implements the iterable interface.\n    return {\n      [Symbol.iterator]() {\n        const visited = new NativeSet()\n        const startPath = targetRange && targetRange.start.path\n        const endPath = targetRange && targetRange.end.path\n        let path = targetPath\n        let node = targetNode\n        let includedTarget = false\n        let includedStart = false\n        let includingStart = false\n\n        const result = () => {\n          // When these are nulled out we've finished iterating.\n          if (!path || !node) {\n            return { done: true }\n          }\n\n          // We often don't want to include the root node itself.\n          if (!includeRoot && node === root) {\n            return next()\n          }\n\n          if (!includeBlocks && node.object === 'block') {\n            return next()\n          }\n\n          if (!includeDocument && node.object === 'document') {\n            return next()\n          }\n\n          if (!includeInlines && node.object === 'inline') {\n            return next()\n          }\n\n          if (!includeTexts && node.object === 'text') {\n            return next()\n          }\n\n          if (match && !match(node, path)) {\n            return next()\n          }\n\n          return { value: [node, path], done: false }\n        }\n\n        const next = () => {\n          if (!path || !node) {\n            return result()\n          }\n\n          // When iterating over a range, we need to include the specific\n          // ancestors in the start path of the range manually.\n          if (startPath && !includedStart) {\n            if (!includingStart) {\n              includingStart = true\n              path = PathUtils.create([])\n              node = root\n              return result()\n            }\n\n            if (path.size === startPath.size - 1) {\n              includedStart = true\n              path = targetPath\n              node = targetNode\n              return next()\n            }\n\n            path = startPath.slice(0, path.size + 1)\n            node = root.assertNode(path)\n            return result()\n          }\n\n          // Sometimes we want to include the target itself.\n          if (includeTarget && !includedTarget) {\n            includedTarget = true\n            return result()\n          }\n\n          // When iterating over a range, if we get to the end path then exit.\n          if (endPath && path.equals(endPath)) {\n            node = null\n            path = null\n            return next()\n          }\n\n          // If we're allowed to go downward, and we haven't decsended yet, do so.\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\n            visited.add(node)\n            const nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1\n            path = path.push(nextIndex)\n            node = root.assertNode(path)\n            return result()\n          }\n\n          // If we're going forward...\n          if (direction === 'forward') {\n            const newPath = PathUtils.increment(path)\n            const newNode = root.getNode(newPath)\n\n            if (newNode) {\n              path = newPath\n              node = newNode\n              return result()\n            }\n          }\n\n          // If we're going backward...\n          if (direction === 'backward' && path.last() !== 0) {\n            const newPath = PathUtils.decrement(path)\n            const newNode = root.getNode(newPath)\n\n            if (newNode) {\n              path = newPath\n              node = newNode\n              return result()\n            }\n          }\n\n          // If we're going upward...\n          if (upward && path.size) {\n            path = PathUtils.lift(path)\n            node = root.assertNode(path)\n\n            // Sometimes we'll have already visited the node on the way down\n            // so we don't want to double count it.\n            if (visited.has(node)) {\n              return next()\n            }\n\n            visited.add(node)\n\n            // If ancestors of the target node shouldn't be included, skip them.\n            if (!includeTargetAncestors) {\n              return next()\n            } else {\n              return result()\n            }\n          }\n\n          path = null\n          node = null\n          return next()\n        }\n\n        return { next }\n      },\n    }\n  }\n\n  /**\n   * Create a point with `properties` relative to the node.\n   *\n   * @param {Object|Point} properties\n   * @return {Range}\n   */\n\n  createPoint(properties) {\n    properties = Point.createProperties(properties)\n    const point = this.resolvePoint(properties)\n    return point\n  }\n\n  /**\n   * Create a range with `properties` relative to the node.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  createRange(properties) {\n    properties = Range.createProperties(properties)\n    const range = this.resolveRange(properties)\n    return range\n  }\n\n  /**\n   * Create a selection with `properties` relative to the node.\n   *\n   * @param {Object|Selection} properties\n   * @return {Selection}\n   */\n\n  createSelection(properties) {\n    properties = Selection.createProperties(properties)\n    const selection = this.resolveSelection(properties)\n    return selection\n  }\n\n  /**\n   * Create an iteratable for all of the descendants of the node.\n   *\n   * @param {Object} options\n   * @return {Iterable}\n   */\n\n  descendants(options) {\n    const iterable = this.createIterable({ path: [], ...options })\n    return iterable\n  }\n\n  /**\n   * Find all of the descendants that match a `predicate`.\n   *\n   * @param {Function} predicate\n   * @return {List<Node>}\n   */\n\n  filterDescendants(predicate = identity) {\n    const matches = []\n\n    for (const [node, path] of this.descendants()) {\n      if (predicate(node, path)) {\n        matches.push(node)\n      }\n    }\n\n    return List(matches)\n  }\n\n  /**\n   * Find the first descendant that matches a `predicate`.\n   *\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  findDescendant(predicate = identity) {\n    for (const [node, path] of this.descendants()) {\n      if (predicate(node, path)) {\n        return node\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Iterate over all descendants, breaking if `predicate` returns false.\n   *\n   * @param {Function} predicate\n   */\n\n  forEachDescendant(predicate = identity) {\n    for (const next of this.descendants()) {\n      const ret = predicate(...next)\n\n      if (ret === false) {\n        return\n      }\n    }\n  }\n\n  /**\n   * Get a set of the active marks in a `range`. Active marks are marks that are\n   * on every text node in a given range. This is a common distinction for\n   * highlighting toolbar buttons for example.\n   *\n   * TODO: this method needs to be cleaned up, it's very hard to follow and\n   * probably doing unnecessary work.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      const { start } = range\n      return this.getInsertMarksAtPoint(start)\n    }\n\n    const { start, end } = range\n    let startPath = start.path\n    let startOffset = start.offset\n    let endPath = end.path\n    let endOffset = end.offset\n    let startText = this.getDescendant(startPath)\n    let endText = this.getDescendant(endPath)\n\n    if (!startPath.equals(endPath)) {\n      while (!startPath.equals(endPath) && endOffset === 0) {\n        ;[[endText, endPath]] = this.texts({\n          path: endPath,\n          direction: 'backward',\n        })\n\n        endOffset = endText.text.length\n      }\n\n      while (\n        !startPath.equals(endPath) &&\n        startOffset === startText.text.length\n      ) {\n        ;[[startText, startPath]] = this.texts({ path: startPath })\n        startOffset = 0\n      }\n    }\n\n    if (startPath.equals(endPath)) {\n      return startText.marks\n    }\n\n    const startMarks = startText.marks\n\n    // PERF: if start marks is empty we can return early.\n    if (startMarks.size === 0) {\n      return Set()\n    }\n\n    const endMarks = endText.marks\n    let marks = startMarks.intersect(endMarks)\n\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) {\n      return marks\n    }\n\n    ;[[startText, startPath]] = this.texts({ path: startPath })\n\n    while (!startPath.equals(endPath)) {\n      if (startText.text.length !== 0) {\n        marks = marks.intersect(startText.marks)\n\n        if (marks.size === 0) {\n          return Set()\n        }\n      }\n\n      ;[[startText, startPath]] = this.texts({ path: startPath })\n    }\n\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    const iterable = this.ancestors(path)\n    const array = Array.from(iterable, ([node]) => node).reverse()\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const iterable = this.blocks({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n\n    if (!path || path.size > 1) {\n      return null\n    }\n\n    const child = this.nodes.get(path.first())\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches a `predicate`.\n   *\n   * @param {List|String} path\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  getClosest(path, predicate) {\n    for (const [n, p] of this.ancestors(path)) {\n      if (predicate(n, p)) {\n        return n\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosest(path, n => editor.isVoid(n))\n    return closest\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n\n    if (!a || !b) {\n      return null\n    }\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {List}\n   */\n\n  getDecorations(editor) {\n    let decorations = editor.run('decorateNode', this)\n    decorations = Decoration.createList(decorations)\n    return decorations\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      return null\n    }\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n\n    if (!path || !path.size) {\n      return null\n    }\n\n    let node = this\n\n    path.forEach(index => {\n      node = node.getIn(['nodes', index])\n      return !!node\n    })\n\n    return node\n  }\n\n  /**\n   * Get all of the descendant nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getDescendantsAtRange(range) {\n    const iterable = this.descendants({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { start, end } = range\n    let node = this\n    let targetPath = end.path\n    let targetPosition = end.offset\n    let side = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && side === 'end') {\n        targetPath = start.path\n        targetPosition = start.offset\n        side = 'start'\n      }\n    }\n\n    const startIndex = start.path.first() + 1\n    const endIndex = end.path.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest ancestors of a node that matches a `predicate`.\n   *\n   * @param {Path} path\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, predicate = identity) {\n    const iterable = this.ancestors(path)\n    const results = Array.from(iterable).reverse()\n\n    for (const [n, p] of results) {\n      if (predicate(n, p)) {\n        return n\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest child ancestor of a node at `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getFurthestChild(path) {\n    path = this.resolvePath(path)\n\n    if (!path || !path.size) {\n      return null\n    }\n\n    const furthest = this.nodes.get(path.first())\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const iterable = this.inlines({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const iterable = this.inlines({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a set of marks that would occur on the next insert at a `point` in the\n   * node. This mimics expected rich text editing behaviors of mark contiuation.\n   *\n   * @param {Point} point\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtPoint(point) {\n    point = this.resolvePoint(point)\n    const { path, offset } = point\n    const text = this.getDescendant(path)\n\n    // PERF: we can exit early if the offset isn't at the start of the node.\n    if (offset !== 0) {\n      return text.marks\n    }\n\n    let blockNode\n    let blockPath\n\n    for (const entry of this.ancestors(path)) {\n      const [n, p] = entry\n\n      if (n.object === 'block') {\n        blockNode = n\n        blockPath = p\n      }\n    }\n\n    const relativePath = PathUtils.drop(path, blockPath.size)\n    const [previous] = blockNode.texts({\n      path: relativePath,\n      direction: 'backward',\n    })\n\n    // If there's no previous text, we're at the start of the block, so use\n    // the current text nodes marks.\n    if (!previous) {\n      return text.marks\n    }\n\n    // Otherwise, continue with the previous text node's marks instead.\n    const [previousText] = previous\n    return previousText.marks\n  }\n\n  /**\n   * Get a set of marks that would occur on the next insert at a `range`.\n   * This mimics expected rich text editing behaviors of mark contiuation.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start } = range\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      return this.getInsertMarksAtPoint(start)\n    }\n\n    const text = this.getDescendant(start.path)\n    return text.marks\n  }\n\n  /**\n   * Get the bottom-most block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafBlocksAtRange(range) {\n    const iterable = this.blocks({ range, onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafInlinesAtRange(range) {\n    const iterable = this.inlines({ range, onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Map}\n   */\n\n  getNodesToPathsMap() {\n    const root = this\n    const map =\n      typeof window === 'undefined' ? new global.Map() : new window.Map()\n\n    map.set(root, PathUtils.create([]))\n\n    root.forEachDescendant((node, path) => {\n      map.set(node, path)\n    })\n\n    return map\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const iterable = this.marks()\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const iterable = this.marks({ range })\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksByType(type) {\n    const iterable = this.marks({ onlyTypes: [type] })\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get the block node after a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextBlock(path) {\n    const [entry] = this.blocks({ path, onlyLeaves: true })\n    const block = entry ? entry[0] : null\n    return block\n  }\n\n  /**\n   * Get the next node in the tree, returning siblings or ancestor siblings.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    const iterable = this.createIterable({ path, downward: false })\n    const [entry] = iterable\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    const [entry] = this.siblings(path)\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    const [entry] = this.texts({ path })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the offset for a descendant text node by `path` or `key`.\n   *\n   * @param {List|string} path\n   * @return {Number}\n   */\n\n  getOffset(path) {\n    path = this.resolvePath(path)\n    this.assertDescendant(path)\n\n    // Calculate the offset of the nodes before the highest child.\n    const index = path.first()\n\n    const offset = this.nodes\n      .slice(0, index)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret =\n      path.size === 1\n        ? offset\n        : offset + this.nodes.get(index).getOffset(PathUtils.drop(path))\n\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { start } = range\n    const offset = this.getOffset(start.path) + start.offset\n    return offset\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Get the block node before a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(path) {\n    const [entry] = this.blocks({\n      path,\n      onlyLeaves: true,\n      direction: 'backward',\n    })\n    const block = entry ? entry[0] : null\n    return block\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    const iterable = this.createIterable({\n      path,\n      downward: false,\n      direction: 'backward',\n    })\n\n    const [entry] = iterable\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    const [entry] = this.siblings(path, { direction: 'backward' })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the text node before a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    const [entry] = this.texts({ path, direction: 'backward' })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get only the root block nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List}\n   */\n\n  getRootBlocksAtRange(range) {\n    const iterable = this.blocks({ range, onlyRoots: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get only the root inline nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List}\n   */\n\n  getRootInlinesAtRange(range) {\n    const iterable = this.inlines({ range, onlyRoots: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n\n    for (const [node] of this.texts()) {\n      length += node.text.length\n\n      if (length > offset) {\n        return node\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = getDirection(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const iterable = this.texts()\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as a List.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    const iterable = this.texts({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosestVoid(path, editor)\n    return !!closest\n  }\n\n  /**\n   * Create an iteratable for all of the inlines of a node with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  inlines(options = {}) {\n    const { onlyLeaves, onlyRoots, onlyTypes, match, ...rest } = options\n    const iterable = this.descendants({\n      includeBlocks: false,\n      includeTexts: false,\n      includeDocument: false,\n      ...rest,\n      match: (node, path) => {\n        if (onlyTypes && !onlyTypes.includes(node.type)) {\n          return false\n        } else if (onlyLeaves && !node.isLeafInline()) {\n          return false\n        } else if (onlyRoots && this.getParent(path).object !== 'block') {\n          return false\n        } else if (match && !match(node, path)) {\n          return false\n        } else {\n          return true\n        }\n      },\n    })\n\n    return iterable\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  insertText(path, offset, text) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.insertText(offset, text)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    if (this.object !== 'block') {\n      return false\n    }\n\n    if (this.nodes.some(n => n.object === 'block')) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    if (this.object !== 'inline') {\n      return false\n    }\n\n    if (this.nodes.some(n => n.object === 'inline')) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Check whether a descendant node is inside a `range` by `path`.\n   *\n   * @param {List|String} path\n   * @param {Range} range\n   * @return {Node}\n   */\n\n  isInRange(path, range) {\n    path = this.resolvePath(path)\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return false\n    }\n\n    const toStart = PathUtils.compare(path, range.start.path)\n    const toEnd = PathUtils.compare(path, range.end.path)\n    const isInRange = toStart !== -1 && toEnd !== 1\n    return isInRange\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} predicate\n   * @return {Node}\n   */\n\n  mapChildren(predicate = identity) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = predicate(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} predicate\n   * @return {Node}\n   */\n\n  mapDescendants(predicate = identity) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(predicate)\n      ret = predicate(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all the marks in text nodes with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  marks(options = {}) {\n    const { onlyTypes = null, match, ...rest } = options\n    const texts = this.texts(rest)\n\n    return {\n      [Symbol.iterator]() {\n        const iterator = texts[Symbol.iterator]()\n        let node = null\n        let path = null\n        let remaining = []\n\n        const next = () => {\n          if (remaining.length) {\n            const mark = remaining.shift()\n\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\n              return next()\n            } else if (match && !match(mark, node, path)) {\n              return next()\n            }\n\n            return { value: [mark, node, path], done: false }\n          }\n\n          const { value, done } = iterator.next()\n\n          if (done) {\n            return { done: true }\n          }\n\n          ;[node, path] = value\n          remaining = node.marks.toArray()\n          return next()\n        }\n\n        return { next }\n      },\n    }\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n    // Alternative 1: pass the operation through from apply -> value.moveNode\n    // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n    const op = Operation.create({\n      type: 'move_node',\n      path,\n      newPath,\n    })\n    newPath = PathUtils.transform(path, op).first()\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Remove `mark` from text at `path`.\n   *\n   * @param {List} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.removeMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a `annotation`, relative to the node, ensuring that the keys and\n   * offsets in the annotation exist and that they are synced with the paths.\n   *\n   * @param {Annotation|Object} annotation\n   * @return {Annotation}\n   */\n\n  resolveAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    annotation = annotation.normalize(this)\n    return annotation\n  }\n\n  /**\n   * Resolve a `decoration`, relative to the node, ensuring that the keys and\n   * offsets in the decoration exist and that they are synced with the paths.\n   *\n   * @param {Decoration|Object} decoration\n   * @return {Decoration}\n   */\n\n  resolveDecoration(decoration) {\n    decoration = Decoration.create(decoration)\n    decoration = decoration.normalize(this)\n    return decoration\n  }\n\n  /**\n   * Resolve a `point`, relative to the node, ensuring that the keys and\n   * offsets in the point exist and that they are synced with the paths.\n   *\n   * @param {Point|Object} point\n   * @return {Point}\n   */\n\n  resolvePoint(point) {\n    point = Point.create(point)\n    point = point.normalize(this)\n    return point\n  }\n\n  /**\n   * Resolve a `range`, relative to the node, ensuring that the keys and\n   * offsets in the range exist and that they are synced with the paths.\n   *\n   * @param {Range|Object} range\n   * @return {Range}\n   */\n\n  resolveRange(range) {\n    range = Range.create(range)\n    range = range.normalize(this)\n    return range\n  }\n\n  /**\n   * Resolve a `selection`, relative to the node, ensuring that the keys and\n   * offsets in the selection exist and that they are synced with the paths.\n   *\n   * @param {Selection|Object} selection\n   * @return {Selection}\n   */\n\n  resolveSelection(selection) {\n    selection = Selection.create(selection)\n    selection = selection.normalize(this)\n    return selection\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, properties, newProperties) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.setMark(properties, newProperties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for the siblings in the tree at `path`.\n   *\n   * @param {List|Array} path\n   * @return {Iterable}\n   */\n\n  siblings(path, options) {\n    const iterable = this.createIterable({\n      path,\n      upward: false,\n      downward: false,\n      ...options,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all the text node descendants.\n   *\n   * @param {Object} options\n   * @return {Iterable}\n   */\n\n  texts(options) {\n    const iterable = this.descendants({\n      includeBlocks: false,\n      includeInlines: false,\n      includeDocument: false,\n      ...options,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  getBlocksAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.'\n    )\n\n    return this.getLeafBlocksAtRange(range)\n  }\n\n  getBlocksAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.'\n    )\n\n    return this.getLeafBlocksAtRangeAsArray(range)\n  }\n\n  getInlinesAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.'\n    )\n\n    return this.getLeafInlinesAtRange(range)\n  }\n\n  getInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.'\n    )\n\n    return this.getLeafInlinesAtRangeAsArray(range)\n  }\n\n  getNextTextAndPath(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.'\n    )\n\n    return this.getNextTextEntry(path)\n  }\n\n  getNextDeepMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.'\n    )\n\n    const match = this.getNextMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [nextNode, nextPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        nextNode.object !== 'text' &&\n        nextNode.findFirstDescendantAndPath(iterator, nextPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[nextNode, nextPath] = childMatch\n    }\n\n    if (!nextNode) return null\n\n    return iterator(nextNode)\n      ? [nextNode, nextPath]\n      : this.getNextDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  getPreviousTextAndPath(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.'\n    )\n\n    return this.getPreviousTextEntry(path)\n  }\n\n  findFirstDescendantAndPath(iterator, pathToThisNode) {\n    warning(\n      false,\n      'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.'\n    )\n\n    return this.findDescendantAndPath(iterator, pathToThisNode, false)\n  }\n\n  getPreviousMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.'\n    )\n\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      let previousPath = PathUtils.decrement(p)\n      let previousNode = this.getNode(previousPath)\n\n      while (previousNode && !iterator(previousNode)) {\n        previousPath = PathUtils.decrement(previousPath)\n        previousNode = this.getNode(previousPath)\n      }\n\n      if (previousNode) return [previousNode, previousPath]\n    }\n\n    return null\n  }\n\n  getPreviousDeepMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.'\n    )\n\n    const match = this.getPreviousMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [previousNode, previousPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        previousNode.object !== 'text' &&\n        previousNode.findLastDescendantAndPath(iterator, previousPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[previousNode, previousPath] = childMatch\n    }\n\n    if (!previousNode) return null\n\n    return iterator(previousNode)\n      ? [previousNode, previousPath]\n      : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  findLastDescendantAndPath(iterator, pathToThisNode) {\n    warning(\n      false,\n      'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.'\n    )\n\n    return this.findDescendantAndPath(iterator, pathToThisNode, true)\n  }\n\n  findDescendantAndPath(\n    iterator,\n    pathToThisNode = PathUtils.create([]),\n    findLast = false\n  ) {\n    warning(\n      false,\n      'As of slate@0.47, the `findDescendantAndPath` method is deprecated.'\n    )\n\n    let found\n    let foundPath\n\n    this.forEachDescendantWithPath(\n      (node, path, nodes) => {\n        if (iterator(node, path, nodes)) {\n          found = node\n          foundPath = path\n          return false\n        }\n      },\n      pathToThisNode,\n      findLast\n    )\n\n    return found ? [found, foundPath] : null\n  }\n\n  forEachDescendantWithPath(iterator, path = PathUtils.create([]), findLast) {\n    warning(\n      false,\n      'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.'\n    )\n\n    let nodes = this.nodes\n    let ret\n\n    if (findLast) nodes = nodes.reverse()\n\n    nodes.forEach((child, i) => {\n      const childPath = path.concat(i)\n\n      if (iterator(child, childPath, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object !== 'text') {\n        ret = child.forEachDescendantWithPath(iterator, childPath, findLast)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  getNextMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.'\n    )\n\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n\n      let nextPath = PathUtils.increment(p)\n      let nextNode = this.getNode(nextPath)\n\n      while (nextNode && !iterator(nextNode)) {\n        nextPath = PathUtils.increment(nextPath)\n        nextNode = this.getNode(nextPath)\n      }\n\n      if (nextNode) return [nextNode, nextPath]\n    }\n\n    return null\n  }\n\n  getSelectionIndexes(range, isSelected = true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getSelectionIndexes` method is deprecated.'\n    )\n\n    const { start, end } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // PERF: if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (start.path.equals(end.path)) {\n      const child = this.getFurthestAncestor(start.path)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let startIndex = null\n    let endIndex = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object === 'text') {\n        if (startIndex == null && child.key === start.key) startIndex = i\n        if (endIndex == null && child.key === end.key) endIndex = i + 1\n      } else {\n        if (startIndex == null && child.hasDescendant(start.key)) startIndex = i\n        if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return startIndex == null || endIndex == null\n    })\n\n    if (isSelected && startIndex == null) {\n      startIndex = 0\n    }\n\n    if (isSelected && endIndex == null) {\n      endIndex = this.nodes.size\n    }\n\n    if (startIndex == null) {\n      return null\n    }\n\n    return { start: startIndex, end: endIndex }\n  }\n\n  getTextsBetweenPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.'\n    )\n\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n\n    return this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n  }\n\n  getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.'\n    )\n\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n    const startText = this.getDescendant(startPath)\n\n    // PERF: if the paths are equal, we can just use the start.\n    if (PathUtils.isEqual(startPath, endPath)) {\n      return startText.marks\n    }\n\n    const texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        result.union(text.marks)\n      })\n    })\n  }\n\n  getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.'\n    )\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getDescendant(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getTextsAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object === 'text') {\n        array.push(node)\n      } else {\n        // For the node at start and end of this list, we want to provide a start and end path\n        // For other nodes, we can just get all their text nodes, they are between the paths\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath)\n        )\n      }\n    })\n\n    return array\n  }\n\n  getFurthestAncestor(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.'\n    )\n\n    return this.getFurthestChild(path)\n  }\n\n  getLeafBlocksAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const { start, end } = range\n\n    return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path)\n  }\n\n  getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.'\n    )\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getClosestBlock(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getBlocksAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object !== 'block') {\n        return\n      } else if (node.isLeafBlock()) {\n        array.push(node)\n      } else {\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getLeafBlocksBetweenPathPositionsAsArray(\n            childStartPath,\n            childEndPath\n          )\n        )\n      }\n    })\n\n    return array\n  }\n\n  getBlocksAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getBlocksAsArray` method is deprecated.'\n    )\n\n    const iterable = this.blocks({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getBlocksByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.'\n    )\n\n    const iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getFurthestOnlyChildAncestor(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.'\n    )\n\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  getInlinesAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getInlinesAsArray` method is deprecated.'\n    )\n\n    const array = Array.from(\n      this.inlines({ onlyLeaves: true }),\n      ([node]) => node\n    )\n    return array\n  }\n\n  getInlinesByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.'\n    )\n\n    const array = Array.from(\n      this.inlines({ onlyLeaves: true, onlyTypes: [type] }),\n      ([node]) => node\n    )\n    return array\n  }\n\n  getLeafInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  getOrderedMarks() {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.'\n    )\n    return this.getMarks()\n  }\n\n  getOrderedMarksAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.'\n    )\n    return this.getMarksAtRange(range)\n  }\n\n  getOrderedMarksByType(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.'\n    )\n    return this.getMarksByType(type)\n  }\n\n  getMarksByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.'\n    )\n\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object === 'text'\n        ? memo.concat(node.marks.filter(m => m.type === type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  getMarksAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksAsArray` method is deprecated.'\n    )\n\n    const result = []\n\n    for (const [node] of this.texts()) {\n      result.push(node.marks.toArray())\n    }\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  getRootInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getFurthestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  getTextsAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsAsArray` method is deprecated.'\n    )\n\n    const iterable = this.texts()\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getTextsAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.'\n    )\n\n    const iterable = this.texts({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getMarksAtPosition(path, offset) {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksAtPosition` method is deprecated.'\n    )\n\n    path = this.resolvePath(path)\n    const text = this.getDescendant(path)\n    const currentMarks = text.marks\n\n    if (offset !== 0) {\n      return OrderedSet(currentMarks)\n    }\n\n    const closestBlock = this.getClosestBlock(path)\n\n    // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n    if (closestBlock.text === '') {\n      return OrderedSet(currentMarks)\n    }\n\n    const [previous] = this.texts({ path, direction: 'backward' })\n\n    if (!previous) {\n      return OrderedSet()\n    }\n\n    const [previousText, previousPath] = previous\n\n    if (closestBlock.hasDescendant(previousPath)) {\n      return OrderedSet(previousText.marks)\n    }\n\n    return OrderedSet(currentMarks)\n  }\n\n  getNodesAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.'\n    )\n\n    const iterable = this.descendants({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  isNodeInRange(path, range) {\n    warning(\n      false,\n      'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.'\n    )\n\n    return this.isInRange(path, range)\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  ElementInterface.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(ElementInterface.prototype, [\n  'getBlocksAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesByTypeAsArray',\n  'getInsertMarksAtRange',\n  'getLeafBlocksAtRangeAsArray',\n  'getLeafBlocksAtRangeAsArray',\n  'getLeafInlinesAtRangeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getNodesAtRange',\n  'getNodesToPathsMap',\n  'getOffset',\n  'getOffsetAtRange',\n  'getOrderedMarksBetweenPositions',\n  'getPreviousBlock',\n  'getRootBlocksAtRange',\n  'getRootInlinesAtRangeAsArray',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPathPositionsAsArray',\n])\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline])\n","import mixin from '../utils/mixin'\nimport Annotation from '../models/annotation'\nimport Decoration from '../models/decoration'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nclass RangeInterface {\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchor === this.focus ||\n      (this.anchor.key === this.focus.key &&\n        this.anchor.offset === this.focus.offset)\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is backward.\n   *\n   * @return {Boolean}\n   */\n\n  get isBackward() {\n    const { isUnset, anchor, focus } = this\n\n    if (isUnset) {\n      return null\n    }\n\n    if (anchor.key === focus.key) {\n      return anchor.offset > focus.offset\n    }\n\n    const isBackward = PathUtils.isBefore(focus.path, anchor.path)\n    return isBackward\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    const { isBackward } = this\n    const isForward = isBackward == null ? null : !isBackward\n    return isForward\n  }\n\n  /**\n   * Check whether the range isn't set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    const { anchor, focus } = this\n    const isUnset = anchor.isUnset || focus.isUnset\n    return isUnset\n  }\n\n  /**\n   * Check whether the range is set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return !this.isUnset\n  }\n\n  /**\n   * Get the start point.\n   *\n   * @return {String}\n   */\n\n  get start() {\n    return this.isBackward ? this.focus : this.anchor\n  }\n\n  /**\n   * Get the end point.\n   *\n   * @return {String}\n   */\n\n  get end() {\n    return this.isBackward ? this.anchor : this.focus\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    const range = this.setPoints([this.focus, this.anchor])\n    return range\n  }\n\n  /**\n   * Move the anchor and focus offsets forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveForward(n) {\n    return this.updatePoints(point => point.moveForward(n))\n  }\n\n  /**\n   * Move the anchor and focus offsets backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveBackward(n) {\n    return this.updatePoints(point => point.moveBackward(n))\n  }\n\n  /**\n   * Move the anchor offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorBackward(n) {\n    const range = this.setAnchor(this.anchor.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the anchor offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorForward(n) {\n    const range = this.setAnchor(this.anchor.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(path, offset) {\n    const range = this.setAnchor(this.anchor.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the end offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndBackward(n) {\n    const range = this.setEnd(this.end.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the end offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndForward(n) {\n    const range = this.setEnd(this.end.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's end point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveEndTo(path, offset) {\n    const range = this.setEnd(this.end.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToStartOfNode(node) {\n    const range = this.setEnd(this.end.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToEndOfNode(node) {\n    const range = this.setEnd(this.end.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the focus offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusBackward(n) {\n    const range = this.setFocus(this.focus.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the focus offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusForward(n) {\n    const range = this.setFocus(this.focus.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(path, offset) {\n    const range = this.setFocus(this.focus.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOfNode(node) {\n    const range = this.setFocus(this.focus.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOfNode(node) {\n    const range = this.setFocus(this.focus.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the start offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartBackward(n) {\n    const range = this.setStart(this.start.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the start offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartForward(n) {\n    const range = this.setStart(this.start.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's start point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveStartTo(path, offset) {\n    const range = this.setStart(this.start.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToStartOfNode(node) {\n    const range = this.setStart(this.start.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToEndOfNode(node) {\n    const range = this.setStart(this.start.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move range's points to a new `path` and `offset`.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveTo(path, offset) {\n    return this.updatePoints(point => point.moveTo(path, offset))\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    const range = this.setFocus(this.anchor)\n    return range\n  }\n\n  /**\n   * Move the start point to the end point.\n   *\n   * @return {Range}\n   */\n\n  moveToEnd() {\n    const range = this.setStart(this.end)\n    return range\n  }\n\n  /**\n   * Move the range's points to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToEndOfNode(node) {\n    return this.updatePoints(point => point.moveToEndOfNode(node))\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    const range = this.setAnchor(this.focus)\n    return range\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOfNode(start, end = start) {\n    const range = this.setPoints([\n      this.anchor.moveToStartOfNode(start),\n      this.focus.moveToEndOfNode(end),\n    ])\n\n    return range\n  }\n\n  /**\n   * Move the end point to the start point.\n   *\n   * @return {Range}\n   */\n\n  moveToStart() {\n    const range = this.setEnd(this.start)\n    return range\n  }\n\n  /**\n   * Move the range's points to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToStartOfNode(node) {\n    return this.updatePoints(point => point.moveToStartOfNode(node))\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    return this.updatePoints(point => point.normalize(node))\n  }\n\n  /**\n   * Set the anchor point to a new `anchor`.\n   *\n   * @param {Point} anchor\n   * @return {Range}\n   */\n\n  setAnchor(anchor) {\n    const range = this.set('anchor', anchor)\n    return range\n  }\n\n  /**\n   * Set the end point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setEnd(point) {\n    const range = this.isBackward ? this.setAnchor(point) : this.setFocus(point)\n    return range\n  }\n\n  /**\n   * Set the focus point to a new `focus`.\n   *\n   * @param {Point} focus\n   * @return {Range}\n   */\n\n  setFocus(focus) {\n    const range = this.set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points to new `values`.\n   *\n   * @param {Array<Point>} values\n   * @return {Range}\n   */\n\n  setPoints(values) {\n    const [anchor, focus] = values\n    const range = this.set('anchor', anchor).set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points with `updater` callback\n   *\n   * @param {Function} updater\n   * @return {Range}\n   */\n\n  updatePoints(updater) {\n    let { anchor, focus } = this\n    anchor = updater(anchor)\n    focus = updater(focus)\n    return this.merge({ anchor, focus })\n  }\n\n  /**\n   * Set the start point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setStart(point) {\n    const range = this.isBackward ? this.setFocus(point) : this.setAnchor(point)\n    return range\n  }\n\n  /**\n   * Set new `properties` on the range.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Range.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const range = this.merge(props)\n    return range\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n\n  /**\n   * Return a `Range` instance from any range-like instance.\n   *\n   * @return {Range}\n   */\n\n  toRange() {\n    const properties = Range.createProperties(this)\n    const range = Range.create(properties)\n    return range\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  unset() {\n    const range = this.updatePoints(p => p.unset())\n    return range\n  }\n}\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection])\n","import './interfaces/object'\nimport './interfaces/model'\nimport './interfaces/node'\nimport './interfaces/element'\nimport './interfaces/range'\n\nimport Annotation from './models/annotation'\nimport Block from './models/block'\nimport Change from './models/change'\nimport Data from './models/data'\nimport Decoration from './models/decoration'\nimport Document from './models/document'\nimport Editor from './controllers/editor'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport PathUtils from './utils/path-utils'\nimport Point from './models/point'\nimport Range from './models/range'\nimport Selection from './models/selection'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Annotation,\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Annotation,\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"],"names":["n","generate","create","key","Error","setGenerator","func","resetGenerator","compare","path","target","m","min","i","pv","get","tv","size","attrs","List","isList","Array","isArray","crop","a","b","ca","slice","cb","decrement","index","increment","getAncestors","ancestors","withMutations","push","value","newValue","newPath","set","isAbove","p","t","isAfter","isBefore","isEqual","equals","isOlder","pl","tl","isPath","any","every","isSibling","butLast","isYounger","lift","ancestor","drop","relative","max","Math","relate","array","av","bv","transform","operation","type","position","pIndex","pEqual","pYounger","pAbove","np","concat","paths","DEFAULTS","undefined","Point","point","isUnset","is","offset","PathUtils","range","isAfterPoint","end","start","isBeforePoint","node","last","getLastText","text","length","first","getFirstText","object","hasNode","moveForward","setOffset","moveBackward","merge","moveTo","getNode","getPath","getTextAtOffset","before","getOffset","block","getClosestBlock","next","getNextText","KeyUtils","options","toArray","preserveKeys","isSet","isPoint","isPlainObject","fromJSON","Record","Data","Map","isMap","fromJS","Mark","data","toJSON","isMark","elements","Set","marks","map","props","mark","item","Decoration","properties","createProperties","decoration","anchor","focus","isDecoration","Range","isRange","list","JSON","stringify","Selection","selection","isFocused","isSelection","createSet","TYPES","isObject","Annotation","annotation","isAnnotation","obj","Document","nodes","isDocument","document","Node","createList","Inline","isInline","inline","Text","add","union","decorations","leaves","split","leaf","at","formats","format","o","middle","after","string","remove","newProperties","newMark","one","two","regenerateKey","other","isText","isNode","kind","Block","forEach","el","texts","isBlock","Value","annotations","updatePoints","normalize","addMark","insertNode","mapRanges","setPath","assertNode","insertText","mapPoints","newDocument","mergeNode","resolvePath","withPath","moveAnchorTo","moveFocusTo","newIndex","moveNode","delete","removeMark","prev","getPreviousText","removeNode","unset","removeText","setNode","setMark","resolveAnnotation","setProperties","resolveSelection","splitNode","iterator","skipNormalize","oldSelection","newSelection","createSelection","anns","createAnnotation","filter","preserveData","preserveAnnotations","toObject","preserveSelection","getClosestInline","getDescendant","getNextBlock","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getActiveMarksAtRange","getLeafBlocksAtRange","getFragmentAtRange","getLeafInlinesAtRange","getTextsAtRange","isValue","createMap","moveToStartOfNode","debug","Debug","applyOperation","op","Operation","window","ENABLE_SLATE_LOGGING","console","log","substring","addAnnotation","removeAnnotation","setAnnotation","setSelection","invertOperation","inversePath","inverseNewPath","inverse","replace","OPERATION_ATTRIBUTES","apply","inverted","invert","json","ATTRIBUTES","v","toJS","isOperation","Change","operations","isChange","change","CommandsPlugin","commands","onCommand","command","editor","args","fn","onConstruct","registerCommand","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isModifier","charCodeAt","isVariationSelector","isBMPEmoji","isWord","char","remaining","test","charAt","getCharLength","rest","getCharOffset","chars","forward","charCode","modifier","nextCharCode","getCharOffsetBackward","reverse","getCharOffsetForward","getWordOffset","started","l","getWordOffsetBackward","getWordOffsetForward","deleteExpandedAtRange","isExpanded","deleteAtRange","hasDescendant","moveToStart","Commands","addMarkAtRange","isCollapsed","withoutNormalizing","addMarkByKey","addMarksAtRange","snapshotSelection","startKey","startOffset","endKey","endOffset","isStartVoid","hasVoidParent","isEndVoid","startBlock","endBlock","isHanging","prevText","startVoid","getClosestVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startText","endText","startLength","endLength","getCommonAncestor","startChild","getFurthestChild","endChild","startParent","getParent","startParentIndex","indexOf","endParentIndex","child","parent","afters","startChildIndex","endChildIndex","middles","befores","onlyChildAncestor","moveNodeByKey","mergeNodeByKey","deleteBackwardAtRange","voidParent","isAtStartOfNode","prevBlock","prevVoid","moveFocusBackward","traversed","deleteCharBackwardAtRange","TextUtils","deleteCharForwardAtRange","deleteForwardAtRange","isVoid","nextBlock","isAtEndOfNode","nextVoid","moveFocusForward","deleteLineBackwardAtRange","deleteLineForwardAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","wordOffset","insertBlockAtRange","startInline","insertionMode","getInsertionMode","insertNodeByKey","atEnd","siblingText","splitRange","moveToEndOfNode","splitDescendantsByKey","insertFragmentAtRange","fragment","mapDescendants","isAtStart","blocks","getBlocks","firstChild","lastChild","firstBlock","lastBlock","insertionNode","findInsertionNode","hasBlockChildren","lonelyParent","getFurthest","lonelyChild","startIndex","excludingLonelyChild","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","findDescendant","inlineChild","inlineIndex","documentKey","deepestSingleBlock","result","doc","ancestorTypesMatch","fragmentAncestors","documentAncestors","fragmentNode","matchingFragmentAncestor","depthDifference","fragIdx","docIdx","getAncestorBlocks","fragmentStartBlock","insertInlineAtRange","assertDescendant","splitNodeByPath","insertTextAtRange","insertTextByPath","removeMarkAtRange","removeMarkByKey","setBlocksAtRange","sets","setNodeByKey","setInlinesAtRange","inlines","splitBlockAtRange","height","h","isBackward","flip","moveAnchorToStartOfNode","setFocus","resolveRange","splitInlineAtRange","Infinity","toggleMarkAtRange","exists","some","unwrapBlockAtRange","wrappers","getClosest","isSuperset","toOrderedSet","toList","children","firstMatch","lastMatch","takeUntil","firstText","extra","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","reduce","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","endIndex","splitText","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","wrapTextAtRange","prefix","suffix","startRange","endRange","moveToEnd","addMarkByPath","addMarksByPath","replaceMarksByPath","marksSet","marksToApply","subtract","marksToRemove","insertFragmentByPath","insertNodeByPath","values","isAtomic","mergeNodeByPath","original","previous","getPreviousSibling","moveNodeByPath","newParentPath","removeMarkByPath","removeMarksByPath","intersect","isEmpty","removeAllMarksByPath","state","pth","removeNodeByPath","removeTextByPath","replaceNodeByPath","newNode","parentPath","replaceTextByPath","setMarkByPath","setNodeByPath","prevProperties","pick","Object","keys","setTextByPath","splitDescendantsByPath","textPath","textOffset","lastPath","splitNodeByKey","ancestorPath","unwrapInlineByPath","moveToRangeOfNode","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","unwrapChildrenByPath","childIndex","childPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","COMMANDS","method","assertPath","newKey","textKey","save","Date","now","tmp","isValidOperation","undos","lastBatch","lastOperation","shouldMerge","batch","pop","takeLast","withoutSaving","redos","newData","setData","redo","omit","undo","withoutMerging","blur","select","deselect","proxy","moveAnchorBackward","pointBackward","moveAnchorWordBackward","pointWordBackward","moveAnchorForward","pointForward","moveAnchorWordForward","pointWordForward","moveAnchorToEndOfBlock","pointEdgeObject","moveAnchorToEndOfInline","moveAnchorToEndOfDocument","moveAnchorToEndOfNode","moveToAnchor","moveAnchorToEndOfNextBlock","pointEdgeSideObject","moveAnchorToEndOfNextInline","moveAnchorToEndOfNextText","moveAnchorToEndOfPreviousBlock","moveAnchorToEndOfPreviousInline","moveAnchorToEndOfPreviousText","moveAnchorToEndOfText","moveAnchorToStartOfBlock","moveAnchorToStartOfDocument","moveAnchorToStartOfInline","moveAnchorToStartOfNextBlock","moveAnchorToStartOfNextInline","moveAnchorToStartOfNextText","moveAnchorToStartOfPreviousBlock","moveAnchorToStartOfPreviousInline","moveAnchorToStartOfPreviousText","moveAnchorToStartOfText","charsOffset","moveWordBackward","moveFocusWordBackward","moveToFocus","moveEndBackward","moveEndWordBackward","moveEndForward","moveEndWordForward","moveEndTo","moveEndToEndOfBlock","moveEndToEndOfDocument","moveEndToEndOfNode","moveEndToEndOfInline","moveEndToEndOfNextBlock","moveEndToEndOfNextInline","moveEndToEndOfNextText","moveEndToEndOfPreviousBlock","moveEndToEndOfPreviousInline","moveEndToEndOfPreviousText","moveEndToEndOfText","moveEndToStartOfBlock","moveEndToStartOfDocument","moveEndToStartOfNode","moveEndToStartOfInline","moveEndToStartOfNextBlock","moveEndToStartOfNextInline","moveEndToStartOfNextText","moveEndToStartOfPreviousBlock","moveEndToStartOfPreviousInline","moveEndToStartOfPreviousText","moveEndToStartOfText","moveFocusWordForward","moveFocusToEndOfBlock","moveFocusToEndOfDocument","moveFocusToEndOfNode","moveFocusToEndOfInline","moveFocusToEndOfNextBlock","moveFocusToEndOfNextInline","moveFocusToEndOfNextText","moveFocusToEndOfPreviousBlock","moveFocusToEndOfPreviousInline","moveFocusToEndOfPreviousText","moveFocusToEndOfText","moveFocusToStartOfBlock","moveFocusToStartOfDocument","moveFocusToStartOfNode","moveFocusToStartOfInline","moveFocusToStartOfNextBlock","moveFocusToStartOfNextInline","moveFocusToStartOfNextText","moveFocusToStartOfPreviousBlock","moveFocusToStartOfPreviousInline","moveFocusToStartOfPreviousText","moveFocusToStartOfText","moveWordForward","moveStartBackward","moveStartWordBackward","moveStartForward","moveStartWordForward","moveStartTo","moveStartToEndOfBlock","moveStartToEndOfDocument","moveStartToEndOfNode","moveStartToEndOfInline","moveStartToEndOfNextBlock","moveStartToEndOfNextInline","moveStartToEndOfNextText","moveStartToEndOfPreviousBlock","moveStartToEndOfPreviousInline","moveStartToEndOfPreviousText","moveStartToEndOfText","moveStartToStartOfBlock","moveStartToStartOfDocument","moveStartToStartOfNode","moveStartToStartOfInline","moveStartToStartOfNextBlock","moveStartToStartOfNextInline","moveStartToStartOfNextText","moveStartToStartOfPreviousBlock","moveStartToStartOfPreviousInline","moveStartToStartOfPreviousText","moveStartToStartOfText","moveToEndOfBlock","moveToEndOfDocument","moveToEndOfInline","moveToEndOfNextBlock","moveToEndOfNextInline","moveToEndOfNextText","moveToEndOfPreviousBlock","moveToEndOfPreviousInline","moveToEndOfPreviousText","moveToEndOfText","moveToRangeOfDocument","moveToStartOfBlock","moveToStartOfDocument","moveToStartOfInline","moveToStartOfNextBlock","moveToStartOfNextInline","moveToStartOfNextText","moveToStartOfPreviousBlock","moveToStartOfPreviousInline","moveToStartOfPreviousText","moveToStartOfText","snapshot","k","skip","setAnchor","setEnd","setStart","edge","toUpperCase","Edge","side","Side","getDirectionNode","isInBlock","isPreviousInVoid","isNextInVoid","pointName","setAnnotations","QueriesPlugin","queries","query","registerQuery","onQuery","ret","SlateError","captureStackTrace","constructor","stack","SchemaPlugin","schema","rules","schemaRules","rule","find","r","testRules","match","normalizeNode","error","validateNode","matches","failure","validateRules","Queries","defaultNormalize","getTexts","valid","fail","validateObject","validateType","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","getMarks","def","defs","count","lastCount","nextDef","shift","rewind","err","validateParent","validatePrevious","validateNext","lastMin","deleteExpanded","sel","addMarks","deleteBackward","deleteCharBackward","deleteLineBackward","deleteWordBackward","deleteForward","deleteCharForward","deleteLineForward","deleteWordForward","insertBlock","insertFragment","from","newTexts","includes","fragmentLength","insertInline","getInsertMarksAtRange","replaceMark","oldMark","setBlocks","setInlines","splitBlock","depth","splitInline","toggleMark","activeMarks","has","unwrapBlock","unwrapInline","wrapBlock","wrapInline","wrapText","isForward","CorePlugin","plugins","AtRange","ByPath","OnHistory","OnSelection","OnValue","WithIntent","Schema","Editor","controller","construct","onChange","readOnly","middleware","core","run","setReadOnly","setValue","newDirtyPaths","getDirtyPaths","dirty","transformed","pathIndex","dirtyPaths","prototype","dirtyPath","join","flushing","resolve","then","flush","__command","__query","table","getKeysToPathsTable","fns","overrides","defineProperty","nextPath","previousPath","oldAncestors","arr","newAncestors","normalizeDirtyPaths","normalizeNodeByPath","iterations","found","registerPlugin","plugin","commandsPlugin","queriesPlugin","schemaPlugin","Leaf","newMarks","isLeaf","invalid","findLast","firstLeaf","cache","unshift","left","right","of","take","mixin","Interface","Classes","Class","getOwnPropertyNames","name","hasOwnProperty","desc","getOwnPropertyDescriptor","TYPE","camel","ObjectInterface","bind","entries","toLowerCase","ModelInterface","ENABLED","LEAF","Symbol","STORE_KEY","UNDEFINED","NULL","UNSET","memoizeStore","WeakMap","memoize","property","noArgs","hasArgs","takesArguments","cachedValue","getIn","setIn","newChild","resetMemoization","useMemoization","enabled","NodeInterface","descendant","nested","descendants","dict","memo","c","normalizer","identity","ElementInterface","replaceNode","iterable","createIterable","onlyLeaves","onlyRoots","onlyTypes","isLeafBlock","resolveDecoration","direction","downward","upward","includeBlocks","includeDocument","includeInlines","includeRoot","includeTarget","includeTargetAncestors","includeTexts","root","targetPath","targetRange","targetNode","NativeSet","global","visited","startPath","endPath","includedTarget","includedStart","includingStart","done","nextIndex","resolvePoint","predicate","getInsertMarksAtPoint","startMarks","endMarks","closest","startAt","targetPosition","results","furthest","blockNode","blockPath","entry","relativePath","previousText","forEachDescendant","OrderedSet","dir","getDirection","getChild","isLeafInline","splice","toStart","toEnd","isInRange","mergeText","deep","flatMap","x","deleteIn","getLeafBlocksAtRangeAsArray","getLeafInlinesAtRangeAsArray","getNextTextEntry","getNextMatchingNodeAndPath","nextNode","childMatch","assign","findFirstDescendantAndPath","getNextDeepMatchingNodeAndPath","getPreviousTextEntry","pathToThisNode","findDescendantAndPath","previousNode","getPreviousMatchingNodeAndPath","findLastDescendantAndPath","getPreviousDeepMatchingNodeAndPath","foundPath","forEachDescendantWithPath","isSelected","getFurthestAncestor","getTextsBetweenPathPositionsAsArray","getTextsAsArray","childStartPath","childEndPath","getLeafBlocksBetweenPathPositionsAsArray","getBlocksAsArray","getTextsAtRangeAsArray","getMarksByType","getMarksByTypeAsArray","getFurthestInline","currentMarks","closestBlock","getText","ASSERTS","RangeInterface","setPoints","updater"],"mappings":"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"}